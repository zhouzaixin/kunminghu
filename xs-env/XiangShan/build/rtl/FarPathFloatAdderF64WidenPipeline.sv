// Generated by CIRCT firtool-1.62.1
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

module FarPathFloatAdderF64WidenPipeline(
  input         clock,
  input         io_fire,
  input  [63:0] io_fp_a,
  input  [63:0] io_fp_b,
  output [63:0] io_fp_c,
  input         io_is_sub,
  input  [2:0]  io_round_mode,
  output [4:0]  io_fflags,
  output [10:0] io_absEaSubEb,
  output        io_isEfp_bGreater
);

  wire         NX;
  wire         OF;
  wire [53:0]  _U_FS1_io_result;
  wire [53:0]  _U_FS0_io_result;
  wire [109:0] _U_far_rshift_2_io_result;
  wire [109:0] _U_far_rshift_1_io_result;
  wire [10:0]  _U_Efp_bSubEfp_a_io_c;
  wire [10:0]  _U_Efp_aSubEfp_b_io_c;
  wire         efficient_fp_b_sign = io_fp_b[63] ^ io_is_sub;
  wire         EOP = io_fp_a[63] ^ efficient_fp_b_sign;
  reg          EOP_reg;
  reg          RNE_reg;
  reg          RTZ_reg;
  reg          RDN_reg;
  reg          RUP_reg;
  reg          RMM_reg;
  wire         _GEN = io_fp_a[52] | ~(|(io_fp_a[62:52]));
  wire         _GEN_0 = io_fp_b[52] | ~(|(io_fp_b[62:52]));
  wire         isEfp_bGreater = io_fp_b[62:52] > io_fp_a[62:52];
  wire [10:0]  absEaSubEb =
    isEfp_bGreater ? _U_Efp_bSubEfp_a_io_c : _U_Efp_aSubEfp_b_io_c;
  wire [52:0]  significand_fp_a = {|(io_fp_a[62:52]), io_fp_a[51:0]};
  wire [52:0]  significand_fp_b = {|(io_fp_b[62:52]), io_fp_b[51:0]};
  wire [52:0]  greaterSignificand = isEfp_bGreater ? significand_fp_b : significand_fp_a;
  wire [53:0]  _A_wire_FS1_T = {greaterSignificand, 1'h0};
  wire [53:0]  _A_wire_FS1_T_1 = {1'h0, greaterSignificand};
  wire [53:0]  A_wire = EOP ? _A_wire_FS1_T : _A_wire_FS1_T_1;
  wire [109:0] far_rshift_widen_result =
    isEfp_bGreater ? _U_far_rshift_2_io_result : _U_far_rshift_1_io_result;
  wire         absEaSubEb_is_greater = absEaSubEb > 11'h38;
  wire [53:0]  B_wire =
    absEaSubEb_is_greater ? {54{EOP}} : far_rshift_widen_result[109:56];
  reg          B_guard_normal_reg;
  reg          B_round_normal_reg;
  reg          B_sticky_normal_reg_r;
  reg          B_sticky_normal_reg_r_1;
  reg  [53:0]  B_sticky_normal_reg_r_2;
  reg  [53:0]  B_sticky_normal_reg_r_3;
  wire         B_rsticky_normal_reg =
    B_round_normal_reg
    | (B_sticky_normal_reg_r
         ? B_sticky_normal_reg_r_1
         : EOP_reg ? (|B_sticky_normal_reg_r_2) : (|B_sticky_normal_reg_r_3));
  wire [1:0]   _lgs_normal_reg_T_5 = {B_guard_normal_reg, B_rsticky_normal_reg};
  wire [1:0]   _lgs_normal_reg_T_6 =
    EOP_reg ? 2'(~_lgs_normal_reg_T_5 + 2'h1) : _lgs_normal_reg_T_5;
  reg          far_sign_result_reg;
  wire         _far_case_overflow_round_up_T_13 = RDN_reg & far_sign_result_reg;
  wire         far_case_normal_round_up =
    EOP_reg & ~(_lgs_normal_reg_T_6[1]) & ~(_lgs_normal_reg_T_6[0]) | RNE_reg
    & _lgs_normal_reg_T_6[1] & (_U_FS0_io_result[0] | _lgs_normal_reg_T_6[0])
    | _far_case_overflow_round_up_T_13 & (|_lgs_normal_reg_T_6) | RUP_reg
    & ~far_sign_result_reg & (|_lgs_normal_reg_T_6) | RMM_reg & _lgs_normal_reg_T_6[1];
  reg          grs_overflow_r;
  reg          grs_overflow_r_1;
  wire [2:0]   grs_overflow =
    EOP_reg
      ? 3'({grs_overflow_r, 2'h0}
           - {grs_overflow_r_1, B_guard_normal_reg, B_rsticky_normal_reg})
      : {_U_FS0_io_result[0], B_guard_normal_reg, B_rsticky_normal_reg};
  wire         _lgs_overflow_T_4 = grs_overflow[1] | grs_overflow[0];
  wire         far_case_overflow_round_up =
    EOP_reg & ~(grs_overflow[2]) & ~_lgs_overflow_T_4 | RNE_reg & grs_overflow[2]
    & (_U_FS0_io_result[1] | _lgs_overflow_T_4) | _far_case_overflow_round_up_T_13
    & (grs_overflow[2] | _lgs_overflow_T_4) | RUP_reg & ~far_sign_result_reg
    & (grs_overflow[2] | _lgs_overflow_T_4) | RMM_reg & grs_overflow[2];
  reg          far_exponent_result_r;
  reg  [10:0]  far_exponent_result_r_1;
  reg  [10:0]  far_exponent_result_r_2;
  reg          OF_r;
  assign OF =
    OF_r
    & (_U_FS0_io_result[53] | _U_FS1_io_result[53] & _U_FS0_io_result[0]
       & far_case_normal_round_up);
  assign NX =
    (_U_FS0_io_result[53]
       ? (|{grs_overflow[2], _lgs_overflow_T_4})
       : (|_lgs_normal_reg_T_6)) | OF;
  wire [10:0]  E_greater = isEfp_bGreater ? io_fp_b[62:52] : io_fp_a[62:52];
  wire [10:0]  EA = EOP ? 11'(E_greater - 11'h1) : E_greater;
  wire [10:0]  _EA_add1_T = 11'(EA + 11'h1);
  always @(posedge clock) begin
    if (io_fire) begin
      EOP_reg <= EOP;
      RNE_reg <= io_round_mode == 3'h0;
      RTZ_reg <= io_round_mode == 3'h1;
      RDN_reg <= io_round_mode == 3'h2;
      RUP_reg <= io_round_mode == 3'h3;
      RMM_reg <= io_round_mode == 3'h4;
      B_guard_normal_reg <=
        ~absEaSubEb_is_greater
        & (EOP ? ~(far_rshift_widen_result[55]) : far_rshift_widen_result[55]);
      B_round_normal_reg <=
        ~absEaSubEb_is_greater
        & (EOP ? ~(far_rshift_widen_result[54]) : far_rshift_widen_result[54]);
      B_sticky_normal_reg_r <= absEaSubEb_is_greater;
      B_sticky_normal_reg_r_1 <= |(isEfp_bGreater ? significand_fp_a : significand_fp_b);
      B_sticky_normal_reg_r_2 <= ~(far_rshift_widen_result[53:0]);
      B_sticky_normal_reg_r_3 <= far_rshift_widen_result[53:0];
      far_sign_result_reg <= isEfp_bGreater ? efficient_fp_b_sign : io_fp_a[63];
      grs_overflow_r <= A_wire[0];
      grs_overflow_r_1 <= ~(B_wire[0]);
      far_exponent_result_r <= EA == 11'h0;
      far_exponent_result_r_1 <= _EA_add1_T;
      far_exponent_result_r_2 <= EA;
      OF_r <= &_EA_add1_T;
    end
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:4];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [2:0] i = 3'h0; i < 3'h5; i += 3'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        EOP_reg = _RANDOM[3'h0][0];
        RNE_reg = _RANDOM[3'h0][1];
        RTZ_reg = _RANDOM[3'h0][2];
        RDN_reg = _RANDOM[3'h0][3];
        RUP_reg = _RANDOM[3'h0][4];
        RMM_reg = _RANDOM[3'h0][5];
        B_guard_normal_reg = _RANDOM[3'h0][6];
        B_round_normal_reg = _RANDOM[3'h0][7];
        B_sticky_normal_reg_r = _RANDOM[3'h0][8];
        B_sticky_normal_reg_r_1 = _RANDOM[3'h0][9];
        B_sticky_normal_reg_r_2 = {_RANDOM[3'h0][31:10], _RANDOM[3'h1]};
        B_sticky_normal_reg_r_3 = {_RANDOM[3'h2], _RANDOM[3'h3][21:0]};
        far_sign_result_reg = _RANDOM[3'h3][23];
        grs_overflow_r = _RANDOM[3'h3][24];
        grs_overflow_r_1 = _RANDOM[3'h3][25];
        far_exponent_result_r = _RANDOM[3'h3][26];
        far_exponent_result_r_1 = {_RANDOM[3'h3][31:27], _RANDOM[3'h4][5:0]};
        far_exponent_result_r_2 = _RANDOM[3'h4][16:6];
        OF_r = _RANDOM[3'h4][17];
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  Adder U_Efp_aSubEfp_b (
    .io_a ({io_fp_a[62:53], _GEN}),
    .io_b ({io_fp_b[62:53], _GEN_0}),
    .io_c (_U_Efp_aSubEfp_b_io_c)
  );
  Adder U_Efp_bSubEfp_a (
    .io_a ({io_fp_b[62:53], _GEN_0}),
    .io_b ({io_fp_a[62:53], _GEN}),
    .io_c (_U_Efp_bSubEfp_a_io_c)
  );
  FarShiftRightWithMuxInvFirst U_far_rshift_1 (
    .io_src
      (EOP
         ? {~significand_fp_b, 57'h1FFFFFFFFFFFFFF}
         : {1'h0, |(io_fp_b[62:52]), io_fp_b[51:0], 56'h0}),
    .io_shiftValue (_U_Efp_aSubEfp_b_io_c[5:0]),
    .io_result     (_U_far_rshift_1_io_result),
    .io_EOP        (EOP)
  );
  FarShiftRightWithMuxInvFirst U_far_rshift_2 (
    .io_src
      (EOP
         ? {~significand_fp_a, 57'h1FFFFFFFFFFFFFF}
         : {1'h0, |(io_fp_a[62:52]), io_fp_a[51:0], 56'h0}),
    .io_shiftValue (_U_Efp_bSubEfp_a_io_c[5:0]),
    .io_result     (_U_far_rshift_2_io_result),
    .io_EOP        (EOP)
  );
  FarPathAdderF64WidenPipeline U_FS0 (
    .clock     (clock),
    .io_fire   (io_fire),
    .io_A      (A_wire),
    .io_B      (B_wire),
    .io_result (_U_FS0_io_result)
  );
  FarPathAdderF64WidenPipeline U_FS1 (
    .clock     (clock),
    .io_fire   (io_fire),
    .io_A      (54'((EOP ? _A_wire_FS1_T : _A_wire_FS1_T_1) + 54'h2)),
    .io_B      (B_wire),
    .io_result (_U_FS1_io_result)
  );
  assign io_fp_c =
    {far_sign_result_reg,
     OF
       ? (RTZ_reg | RDN_reg & ~far_sign_result_reg | RUP_reg & far_sign_result_reg
            ? 63'h7FEFFFFFFFFFFFFF
            : 63'h7FF0000000000000)
       : {_U_FS0_io_result[53] | _U_FS1_io_result[53] & _U_FS0_io_result[0]
          & far_case_normal_round_up | far_exponent_result_r & _U_FS0_io_result[52]
            ? far_exponent_result_r_1
            : far_exponent_result_r_2,
          (~(_U_FS0_io_result[53])
           & (~(_U_FS0_io_result[0]) & far_case_normal_round_up
              | ~far_case_normal_round_up)
             ? {_U_FS0_io_result[51:1], _U_FS0_io_result[0] ^ far_case_normal_round_up}
             : 52'h0)
            | (~(_U_FS0_io_result[53]) & _U_FS0_io_result[0] & far_case_normal_round_up
                 ? {_U_FS1_io_result[51:1], 1'h0}
                 : 52'h0)
            | (_U_FS0_io_result[53]
               & (~(_U_FS0_io_result[1]) & far_case_overflow_round_up
                  | ~far_case_overflow_round_up)
                 ? {_U_FS0_io_result[52:2],
                    _U_FS0_io_result[1] ^ far_case_overflow_round_up}
                 : 52'h0)
            | (_U_FS0_io_result[53] & _U_FS0_io_result[1] & far_case_overflow_round_up
                 ? _U_FS1_io_result[52:1]
                 : 52'h0)}};
  assign io_fflags = {2'h0, OF, 1'h0, NX};
  assign io_absEaSubEb = absEaSubEb;
  assign io_isEfp_bGreater = isEfp_bGreater;
endmodule

