// Generated by CIRCT firtool-1.62.1
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

module CtrlUnit(
  input         clock,
  input         reset,
  output        auto_in_a_ready,
  input         auto_in_a_valid,
  input  [3:0]  auto_in_a_bits_opcode,
  input  [1:0]  auto_in_a_bits_size,
  input  [1:0]  auto_in_a_bits_source,
  input  [29:0] auto_in_a_bits_address,
  input  [7:0]  auto_in_a_bits_mask,
  input  [63:0] auto_in_a_bits_data,
  input         auto_in_d_ready,
  output        auto_in_d_valid,
  output [3:0]  auto_in_d_bits_opcode,
  output [1:0]  auto_in_d_bits_size,
  output [1:0]  auto_in_d_bits_source,
  output [63:0] auto_in_d_bits_data,
  input         io_pseudoError_0_ready,
  output        io_pseudoError_0_valid,
  output        io_pseudoError_0_bits_0_valid,
  output [63:0] io_pseudoError_0_bits_0_mask,
  input         io_pseudoError_1_ready,
  output        io_pseudoError_1_valid,
  output        io_pseudoError_1_bits_0_valid,
  output [63:0] io_pseudoError_1_bits_0_mask,
  output        io_pseudoError_1_bits_1_valid,
  output [63:0] io_pseudoError_1_bits_1_mask,
  output        io_pseudoError_1_bits_2_valid,
  output [63:0] io_pseudoError_1_bits_2_mask,
  output        io_pseudoError_1_bits_3_valid,
  output [63:0] io_pseudoError_1_bits_3_mask,
  output        io_pseudoError_1_bits_4_valid,
  output [63:0] io_pseudoError_1_bits_4_mask,
  output        io_pseudoError_1_bits_5_valid,
  output [63:0] io_pseudoError_1_bits_5_mask,
  output        io_pseudoError_1_bits_6_valid,
  output [63:0] io_pseudoError_1_bits_6_mask,
  output        io_pseudoError_1_bits_7_valid,
  output [63:0] io_pseudoError_1_bits_7_mask
);

  wire              _out_back_q_io_deq_valid;
  wire              _out_back_q_io_deq_bits_read;
  wire [3:0]        _out_back_q_io_deq_bits_index;
  wire [63:0]       _out_back_q_io_deq_bits_data;
  wire [7:0]        _out_back_q_io_deq_bits_mask;
  reg  [63:0]       ctrlRegs_0;
  reg  [63:0]       delayRegs_0;
  reg  [63:0]       maskRegs_0;
  reg  [63:0]       maskRegs_1;
  reg  [63:0]       maskRegs_2;
  reg  [63:0]       maskRegs_3;
  reg  [63:0]       maskRegs_4;
  reg  [63:0]       maskRegs_5;
  reg  [63:0]       maskRegs_6;
  reg  [63:0]       maskRegs_7;
  reg  [63:0]       counterRegs_0;
  wire              io_pseudoError_0_valid_0 =
    ctrlRegs_0[0] & ~(ctrlRegs_0[3]) & (~(ctrlRegs_0[2]) | ~(|counterRegs_0));
  wire              io_pseudoError_1_valid_0 =
    ctrlRegs_0[0] & ctrlRegs_0[3] & (~(ctrlRegs_0[2]) | ~(|counterRegs_0));
  wire              _out_wofireMux_T_2 =
    _out_back_q_io_deq_valid & auto_in_d_ready & ~_out_back_q_io_deq_bits_read;
  wire [15:0][63:0] _GEN =
    {{64'h0},
     {64'h0},
     {64'h0},
     {64'h0},
     {64'h0},
     {64'h0},
     {maskRegs_7},
     {maskRegs_6},
     {maskRegs_5},
     {maskRegs_4},
     {maskRegs_3},
     {maskRegs_2},
     {maskRegs_1},
     {maskRegs_0},
     {delayRegs_0},
     {ctrlRegs_0}};
  wire              _GEN_0 = io_pseudoError_0_ready & io_pseudoError_0_valid_0;
  wire              newCtrlReg_ese = ctrlRegs_0[1] & ctrlRegs_0[0];
  wire              _GEN_1 = io_pseudoError_1_ready & io_pseudoError_1_valid_0;
  wire              newCtrlReg_1_ese = ctrlRegs_0[1] & ctrlRegs_0[0];
  wire [63:0]       out_backMask =
    {{8{_out_back_q_io_deq_bits_mask[7]}},
     {8{_out_back_q_io_deq_bits_mask[6]}},
     {8{_out_back_q_io_deq_bits_mask[5]}},
     {8{_out_back_q_io_deq_bits_mask[4]}},
     {8{_out_back_q_io_deq_bits_mask[3]}},
     {8{_out_back_q_io_deq_bits_mask[2]}},
     {8{_out_back_q_io_deq_bits_mask[1]}},
     {8{_out_back_q_io_deq_bits_mask[0]}}};
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      ctrlRegs_0 <= 64'h0;
      delayRegs_0 <= 64'h0;
      maskRegs_0 <= 64'h0;
      maskRegs_1 <= 64'h0;
      maskRegs_2 <= 64'h0;
      maskRegs_3 <= 64'h0;
      maskRegs_4 <= 64'h0;
      maskRegs_5 <= 64'h0;
      maskRegs_6 <= 64'h0;
      maskRegs_7 <= 64'h0;
      counterRegs_0 <= 64'h0;
    end
    else begin
      if (_out_wofireMux_T_2 & _out_back_q_io_deq_bits_index == 4'h0 & (&out_backMask))
        ctrlRegs_0 <= _out_back_q_io_deq_bits_data;
      else if (_GEN_1)
        ctrlRegs_0 <= {ctrlRegs_0[63:1], newCtrlReg_1_ese};
      else if (_GEN_0)
        ctrlRegs_0 <= {ctrlRegs_0[63:1], newCtrlReg_ese};
      if (_out_wofireMux_T_2 & _out_back_q_io_deq_bits_index == 4'h1
          & (&out_backMask)) begin
        delayRegs_0 <= _out_back_q_io_deq_bits_data;
        counterRegs_0 <= _out_back_q_io_deq_bits_data;
      end
      else if (ctrlRegs_0[0] & ctrlRegs_0[2] & (|counterRegs_0))
        counterRegs_0 <= 64'(counterRegs_0 - 64'h1);
      else if (_GEN_1 & newCtrlReg_1_ese & ctrlRegs_0[2])
        counterRegs_0 <= ctrlRegs_0[1] ? delayRegs_0 : 64'h0;
      else if (_GEN_0 & newCtrlReg_ese & ctrlRegs_0[2])
        counterRegs_0 <= ctrlRegs_0[1] ? delayRegs_0 : 64'h0;
      if (_out_wofireMux_T_2 & _out_back_q_io_deq_bits_index == 4'h2 & (&out_backMask))
        maskRegs_0 <= _out_back_q_io_deq_bits_data;
      if (_out_wofireMux_T_2 & _out_back_q_io_deq_bits_index == 4'h3 & (&out_backMask))
        maskRegs_1 <= _out_back_q_io_deq_bits_data;
      if (_out_wofireMux_T_2 & _out_back_q_io_deq_bits_index == 4'h4 & (&out_backMask))
        maskRegs_2 <= _out_back_q_io_deq_bits_data;
      if (_out_wofireMux_T_2 & _out_back_q_io_deq_bits_index == 4'h5 & (&out_backMask))
        maskRegs_3 <= _out_back_q_io_deq_bits_data;
      if (_out_wofireMux_T_2 & _out_back_q_io_deq_bits_index == 4'h6 & (&out_backMask))
        maskRegs_4 <= _out_back_q_io_deq_bits_data;
      if (_out_wofireMux_T_2 & _out_back_q_io_deq_bits_index == 4'h7 & (&out_backMask))
        maskRegs_5 <= _out_back_q_io_deq_bits_data;
      if (_out_wofireMux_T_2 & _out_back_q_io_deq_bits_index == 4'h8 & (&out_backMask))
        maskRegs_6 <= _out_back_q_io_deq_bits_data;
      if (_out_wofireMux_T_2 & _out_back_q_io_deq_bits_index == 4'h9 & (&out_backMask))
        maskRegs_7 <= _out_back_q_io_deq_bits_data;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:21];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [4:0] i = 5'h0; i < 5'h16; i += 5'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        ctrlRegs_0 = {_RANDOM[5'h0], _RANDOM[5'h1]};
        delayRegs_0 = {_RANDOM[5'h2], _RANDOM[5'h3]};
        maskRegs_0 = {_RANDOM[5'h4], _RANDOM[5'h5]};
        maskRegs_1 = {_RANDOM[5'h6], _RANDOM[5'h7]};
        maskRegs_2 = {_RANDOM[5'h8], _RANDOM[5'h9]};
        maskRegs_3 = {_RANDOM[5'hA], _RANDOM[5'hB]};
        maskRegs_4 = {_RANDOM[5'hC], _RANDOM[5'hD]};
        maskRegs_5 = {_RANDOM[5'hE], _RANDOM[5'hF]};
        maskRegs_6 = {_RANDOM[5'h10], _RANDOM[5'h11]};
        maskRegs_7 = {_RANDOM[5'h12], _RANDOM[5'h13]};
        counterRegs_0 = {_RANDOM[5'h14], _RANDOM[5'h15]};
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        ctrlRegs_0 = 64'h0;
        delayRegs_0 = 64'h0;
        maskRegs_0 = 64'h0;
        maskRegs_1 = 64'h0;
        maskRegs_2 = 64'h0;
        maskRegs_3 = 64'h0;
        maskRegs_4 = 64'h0;
        maskRegs_5 = 64'h0;
        maskRegs_6 = 64'h0;
        maskRegs_7 = 64'h0;
        counterRegs_0 = 64'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  Queue1_RegMapperInput_4 out_back_q (
    .clock                               (clock),
    .reset                               (reset),
    .io_enq_ready                        (auto_in_a_ready),
    .io_enq_valid                        (auto_in_a_valid),
    .io_enq_bits_read                    (auto_in_a_bits_opcode == 4'h4),
    .io_enq_bits_index                   (auto_in_a_bits_address[6:3]),
    .io_enq_bits_data                    (auto_in_a_bits_data),
    .io_enq_bits_mask                    (auto_in_a_bits_mask),
    .io_enq_bits_extra_tlrr_extra_source (auto_in_a_bits_source),
    .io_enq_bits_extra_tlrr_extra_size   (auto_in_a_bits_size),
    .io_deq_ready                        (auto_in_d_ready),
    .io_deq_valid                        (_out_back_q_io_deq_valid),
    .io_deq_bits_read                    (_out_back_q_io_deq_bits_read),
    .io_deq_bits_index                   (_out_back_q_io_deq_bits_index),
    .io_deq_bits_data                    (_out_back_q_io_deq_bits_data),
    .io_deq_bits_mask                    (_out_back_q_io_deq_bits_mask),
    .io_deq_bits_extra_tlrr_extra_source (auto_in_d_bits_source),
    .io_deq_bits_extra_tlrr_extra_size   (auto_in_d_bits_size)
  );
  assign auto_in_d_valid = _out_back_q_io_deq_valid;
  assign auto_in_d_bits_opcode = {3'h0, _out_back_q_io_deq_bits_read};
  assign auto_in_d_bits_data = _GEN[_out_back_q_io_deq_bits_index];
  assign io_pseudoError_0_valid = io_pseudoError_0_valid_0;
  assign io_pseudoError_0_bits_0_valid = ctrlRegs_0[4];
  assign io_pseudoError_0_bits_0_mask = maskRegs_0;
  assign io_pseudoError_1_valid = io_pseudoError_1_valid_0;
  assign io_pseudoError_1_bits_0_valid = ctrlRegs_0[4];
  assign io_pseudoError_1_bits_0_mask = maskRegs_0;
  assign io_pseudoError_1_bits_1_valid = ctrlRegs_0[5];
  assign io_pseudoError_1_bits_1_mask = maskRegs_1;
  assign io_pseudoError_1_bits_2_valid = ctrlRegs_0[6];
  assign io_pseudoError_1_bits_2_mask = maskRegs_2;
  assign io_pseudoError_1_bits_3_valid = ctrlRegs_0[7];
  assign io_pseudoError_1_bits_3_mask = maskRegs_3;
  assign io_pseudoError_1_bits_4_valid = ctrlRegs_0[8];
  assign io_pseudoError_1_bits_4_mask = maskRegs_4;
  assign io_pseudoError_1_bits_5_valid = ctrlRegs_0[9];
  assign io_pseudoError_1_bits_5_mask = maskRegs_5;
  assign io_pseudoError_1_bits_6_valid = ctrlRegs_0[10];
  assign io_pseudoError_1_bits_6_mask = maskRegs_6;
  assign io_pseudoError_1_bits_7_valid = ctrlRegs_0[11];
  assign io_pseudoError_1_bits_7_mask = maskRegs_7;
endmodule

