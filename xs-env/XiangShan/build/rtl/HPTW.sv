// Generated by CIRCT firtool-1.62.1
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

module HPTW(
  input         clock,
  input         reset,
  input         io_sfence_valid,
  input         io_csr_satp_changed,
  input         io_csr_vsatp_changed,
  input  [3:0]  io_csr_hgatp_mode,
  input  [15:0] io_csr_hgatp_vmid,
  input  [43:0] io_csr_hgatp_ppn,
  input         io_csr_hgatp_changed,
  input         io_csr_mPBMTE,
  output        io_req_ready,
  input         io_req_valid,
  input  [1:0]  io_req_bits_source,
  input  [2:0]  io_req_bits_id,
  input  [37:0] io_req_bits_gvpn,
  input  [35:0] io_req_bits_ppn,
  input         io_req_bits_l3Hit,
  input         io_req_bits_l2Hit,
  input         io_req_bits_l1Hit,
  input         io_req_bits_bypassed,
  input         io_resp_ready,
  output        io_resp_valid,
  output [37:0] io_resp_bits_resp_entry_tag,
  output [13:0] io_resp_bits_resp_entry_vmid,
  output        io_resp_bits_resp_entry_n,
  output [1:0]  io_resp_bits_resp_entry_pbmt,
  output [37:0] io_resp_bits_resp_entry_ppn,
  output        io_resp_bits_resp_entry_perm_d,
  output        io_resp_bits_resp_entry_perm_a,
  output        io_resp_bits_resp_entry_perm_g,
  output        io_resp_bits_resp_entry_perm_u,
  output        io_resp_bits_resp_entry_perm_x,
  output        io_resp_bits_resp_entry_perm_w,
  output        io_resp_bits_resp_entry_perm_r,
  output [1:0]  io_resp_bits_resp_entry_level,
  output        io_resp_bits_resp_gpf,
  output        io_resp_bits_resp_gaf,
  output [2:0]  io_resp_bits_id,
  input         io_mem_req_ready,
  output        io_mem_req_valid,
  output [47:0] io_mem_req_bits_addr,
  output        io_mem_req_bits_hptw_bypassed,
  input         io_mem_resp_valid,
  input  [63:0] io_mem_resp_bits,
  input         io_mem_mask,
  output [37:0] io_refill_req_info_vpn,
  output [1:0]  io_refill_req_info_source,
  output [1:0]  io_refill_level,
  output [47:0] io_pmp_req_bits_addr,
  input         io_pmp_resp_ld,
  input         io_pmp_resp_mmio
);

  wire            finish;
  wire [35:0]     _GEN;
  wire            flush =
    io_sfence_valid | io_csr_hgatp_changed | io_csr_satp_changed | io_csr_vsatp_changed;
  reg  [1:0]      level;
  reg  [1:0]      af_level;
  reg  [49:0]     gpaddr;
  reg  [35:0]     req_ppn;
  reg             l3Hit;
  reg             l2Hit;
  reg             l1Hit;
  reg             bypassed;
  wire [3:0][8:0] _GEN_0 =
    {{gpaddr[47:39]}, {gpaddr[38:30]}, {gpaddr[29:21]}, {gpaddr[20:12]}};
  wire            _GEN_1 = io_csr_hgatp_mode == 4'h9;
  wire [47:0]     _GEN_2 = {io_csr_hgatp_ppn[35:0], 12'h0};
  assign _GEN =
    (_GEN_1
       ? (af_level == 2'h2 ? l3Hit : af_level == 2'h1 ? l2Hit : l1Hit)
       : af_level == 2'h1 ? l2Hit : l1Hit)
      ? req_ppn
      : io_mem_resp_bits[45:10];
  wire [47:0]     mem_addr =
    (_GEN_1 ? (&af_level) : af_level == 2'h2)
      ? (_GEN_1
           ? 48'(_GEN_2 + {34'h0, gpaddr[49:39], 3'h0})
           : 48'(_GEN_2 + {34'h0, gpaddr[40:30], 3'h0}))
      : {_GEN, _GEN_0[level], 3'h0};
  reg             s_pmp_check;
  reg             s_mem_req;
  reg             w_mem_resp;
  reg             idle;
  reg             mem_addr_update;
  wire            sent_to_pmp = ~idle & (~s_pmp_check | mem_addr_update) & ~finish;
  wire            _pageFault_T_19 = io_mem_resp_bits[1] | io_mem_resp_bits[3];
  wire            _find_pte_T = io_mem_resp_bits[1] | io_mem_resp_bits[3];
  wire            pageFault =
    (|(io_mem_resp_bits[60:54])) | (&(io_mem_resp_bits[62:61])) | ~io_csr_mPBMTE
    & (|(io_mem_resp_bits[62:61]))
    | (~(_pageFault_T_19 | io_mem_resp_bits[2]) & io_mem_resp_bits[0]
         ? io_mem_resp_bits[4] | io_mem_resp_bits[6] | io_mem_resp_bits[7]
           | io_mem_resp_bits[63] | (|(io_mem_resp_bits[62:61]))
         : ~(io_mem_resp_bits[0]) | ~(io_mem_resp_bits[1]) & io_mem_resp_bits[2]
           | ~(io_mem_resp_bits[4]) | io_mem_resp_bits[63]
           & io_mem_resp_bits[13:10] != 4'h8 | (_pageFault_T_19 | io_mem_resp_bits[2])
           & io_mem_resp_bits[0]
           & ~(~(|level) | level == 2'h1 & io_mem_resp_bits[18:10] == 9'h0 | level == 2'h2
               & io_mem_resp_bits[27:10] == 18'h0 | (&level)
               & io_mem_resp_bits[36:10] == 27'h0) | ~(io_mem_resp_bits[6]))
    | ~((_find_pte_T | io_mem_resp_bits[2]) & io_mem_resp_bits[0]) & ~(|level);
  reg             accessFault;
  wire            ppn_af = (|(io_mem_resp_bits[53:46])) & io_mem_resp_bits[0];
  wire            find_pte =
    (_find_pte_T | io_mem_resp_bits[2]) & io_mem_resp_bits[0] | ppn_af | pageFault;
  wire            resp_valid =
    ~idle & mem_addr_update & (w_mem_resp & find_pte | s_pmp_check & accessFault);
  reg  [2:0]      id;
  wire            _source_T = idle & io_req_valid;
  reg  [1:0]      source;
  wire            resp_gaf = accessFault | ppn_af & ~pageFault;
  wire            io_mem_req_valid_0 =
    ~s_mem_req & ~io_mem_mask & ~accessFault & s_pmp_check;
  wire            _GEN_3 = idle & _source_T;
  wire            _GEN_4 = find_pte | accessFault;
  wire            _GEN_5 = io_resp_ready & resp_valid;
  assign finish = mem_addr_update & _GEN_4 & resp_valid;
  wire [1:0]      _GEN_6 =
    io_req_bits_l1Hit
      ? 2'h0
      : io_req_bits_l2Hit ? 2'h1 : _GEN_1 ? {1'h1, ~io_req_bits_l3Hit} : 2'h2;
  wire            _GEN_7 = sent_to_pmp & ~mem_addr_update;
  wire            _GEN_8 = accessFault & ~idle;
  wire            _GEN_9 = io_mem_req_ready & io_mem_req_valid_0;
  wire            _GEN_10 = io_mem_resp_valid & ~w_mem_resp;
  wire            _GEN_11 = mem_addr_update & ~_GEN_4;
  wire            _GEN_12 = resp_valid & _GEN_5;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      level <= 2'h3;
      af_level <= 2'h3;
      s_pmp_check <= 1'h1;
      s_mem_req <= 1'h1;
      w_mem_resp <= 1'h1;
      idle <= 1'h1;
      mem_addr_update <= 1'h0;
    end
    else begin
      if (_GEN_11)
        level <= 2'(level - 2'h1);
      else if (_GEN_3)
        level <= _GEN_6;
      if (_GEN_10)
        af_level <= 2'(af_level - 2'h1);
      else if (_GEN_3)
        af_level <= _GEN_6;
      s_pmp_check <= flush | _GEN_8 | _GEN_7 | ~_GEN_3 & s_pmp_check;
      s_mem_req <= flush | ~_GEN_11 & (_GEN_9 | _GEN_8 | ~_GEN_7 & s_mem_req);
      w_mem_resp <= flush | _GEN_10 | ~_GEN_9 & (_GEN_8 | w_mem_resp);
      idle <= flush | mem_addr_update & _GEN_4 & _GEN_12 | ~_GEN_3 & idle;
      mem_addr_update <=
        ~(flush | mem_addr_update & (~_GEN_4 | _GEN_12))
        & (_GEN_10 | _GEN_8 | mem_addr_update);
    end
  end // always @(posedge, posedge)
  wire            _GEN_13 = sent_to_pmp ? io_pmp_resp_ld | io_pmp_resp_mmio : accessFault;
  always @(posedge clock) begin
    if (_GEN_3) begin
      gpaddr <= {io_req_bits_gvpn, 12'h0};
      req_ppn <= io_req_bits_ppn;
      l3Hit <= _GEN_1 & io_req_bits_l3Hit;
      l2Hit <= io_req_bits_l2Hit;
      l1Hit <= io_req_bits_l1Hit;
      bypassed <= io_req_bits_bypassed;
      id <= io_req_bits_id;
    end
    accessFault <=
      ~flush
      & (mem_addr_update & _GEN_4 & resp_valid
           ? ~(_GEN_5 | _GEN_3) & _GEN_13
           : ~_GEN_3 & _GEN_13);
    if (_source_T)
      source <= io_req_bits_source;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:3];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [2:0] i = 3'h0; i < 3'h4; i += 3'h1) begin
          _RANDOM[i[1:0]] = `RANDOM;
        end
        level = _RANDOM[2'h0][1:0];
        af_level = _RANDOM[2'h0][3:2];
        gpaddr = {_RANDOM[2'h0][31:4], _RANDOM[2'h1][21:0]};
        req_ppn = {_RANDOM[2'h1][31:22], _RANDOM[2'h2][25:0]};
        l3Hit = _RANDOM[2'h2][26];
        l2Hit = _RANDOM[2'h2][27];
        l1Hit = _RANDOM[2'h2][28];
        bypassed = _RANDOM[2'h2][29];
        s_pmp_check = _RANDOM[2'h2][30];
        s_mem_req = _RANDOM[2'h2][31];
        w_mem_resp = _RANDOM[2'h3][0];
        idle = _RANDOM[2'h3][1];
        mem_addr_update = _RANDOM[2'h3][2];
        accessFault = _RANDOM[2'h3][3];
        id = _RANDOM[2'h3][6:4];
        source = _RANDOM[2'h3][8:7];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        level = 2'h3;
        af_level = 2'h3;
        s_pmp_check = 1'h1;
        s_mem_req = 1'h1;
        w_mem_resp = 1'h1;
        idle = 1'h1;
        mem_addr_update = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_req_ready = idle;
  assign io_resp_valid = resp_valid;
  assign io_resp_bits_resp_entry_tag = gpaddr[49:12];
  assign io_resp_bits_resp_entry_vmid = io_csr_hgatp_vmid[13:0];
  assign io_resp_bits_resp_entry_n = ~resp_gaf & io_mem_resp_bits[63];
  assign io_resp_bits_resp_entry_pbmt = resp_gaf ? 2'h0 : io_mem_resp_bits[62:61];
  assign io_resp_bits_resp_entry_ppn = {2'h0, resp_gaf ? 36'h0 : io_mem_resp_bits[45:10]};
  assign io_resp_bits_resp_entry_perm_d = ~resp_gaf & io_mem_resp_bits[7];
  assign io_resp_bits_resp_entry_perm_a = ~resp_gaf & io_mem_resp_bits[6];
  assign io_resp_bits_resp_entry_perm_g = ~resp_gaf & io_mem_resp_bits[5];
  assign io_resp_bits_resp_entry_perm_u = ~resp_gaf & io_mem_resp_bits[4];
  assign io_resp_bits_resp_entry_perm_x = ~resp_gaf & io_mem_resp_bits[3];
  assign io_resp_bits_resp_entry_perm_w = ~resp_gaf & io_mem_resp_bits[2];
  assign io_resp_bits_resp_entry_perm_r = ~resp_gaf & io_mem_resp_bits[1];
  assign io_resp_bits_resp_entry_level = accessFault ? af_level : level;
  assign io_resp_bits_resp_gpf = pageFault & ~accessFault;
  assign io_resp_bits_resp_gaf = resp_gaf;
  assign io_resp_bits_id = id;
  assign io_mem_req_valid = io_mem_req_valid_0;
  assign io_mem_req_bits_addr = mem_addr;
  assign io_mem_req_bits_hptw_bypassed = bypassed;
  assign io_refill_req_info_vpn = gpaddr[49:12];
  assign io_refill_req_info_source = source;
  assign io_refill_level = level;
  assign io_pmp_req_bits_addr = mem_addr;
endmodule

