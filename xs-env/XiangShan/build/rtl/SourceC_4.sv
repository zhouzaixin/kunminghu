// Generated by CIRCT firtool-1.62.1
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

module SourceC_4(
  input          clock,
  input          reset,
  input          io_c_ready,
  output         io_c_valid,
  output [2:0]   io_c_bits_opcode,
  output [2:0]   io_c_bits_param,
  output [2:0]   io_c_bits_size,
  output [3:0]   io_c_bits_source,
  output [47:0]  io_c_bits_address,
  output [255:0] io_c_bits_data,
  output         io_c_bits_corrupt,
  input          io_bs_raddr_ready,
  output         io_bs_raddr_valid,
  output [2:0]   io_bs_raddr_bits_way,
  output [10:0]  io_bs_raddr_bits_set,
  output         io_bs_raddr_bits_beat,
  input  [255:0] io_bs_rdata_data,
  input          io_bs_rdata_corrupt,
  output         io_task_ready,
  input          io_task_valid,
  input  [2:0]   io_task_bits_opcode,
  input  [30:0]  io_task_bits_tag,
  input  [10:0]  io_task_bits_set,
  input  [2:0]   io_task_bits_param,
  input  [3:0]   io_task_bits_source,
  input  [2:0]   io_task_bits_way
);

  wire [2:0]  _queue_io_count;
  reg         bs_busy;
  reg         back_pressure;
  reg         beat;
  reg  [2:0]  task_latch_opcode;
  reg  [30:0] task_latch_tag;
  reg  [10:0] task_latch_set;
  reg  [2:0]  task_latch_param;
  reg  [3:0]  task_latch_source;
  reg  [2:0]  task_latch_way;
  wire [10:0] task_set = bs_busy ? task_latch_set : io_task_bits_set;
  wire        taskWithData = io_task_valid & ~back_pressure & io_task_bits_opcode[0];
  wire        io_task_ready_0 = ~bs_busy & ~back_pressure;
  wire        has_data = taskWithData | bs_busy;
  reg  [2:0]  s1_task_opcode;
  reg  [30:0] s1_task_tag;
  reg  [10:0] s1_task_set;
  reg  [2:0]  s1_task_param;
  reg  [3:0]  s1_task_source;
  reg         s1_valid;
  reg         pipeOut_pipe_v;
  reg  [2:0]  pipeOut_pipe_b_task_opcode;
  reg  [30:0] pipeOut_pipe_b_task_tag;
  reg  [10:0] pipeOut_pipe_b_task_set;
  reg  [2:0]  pipeOut_pipe_b_task_param;
  reg  [3:0]  pipeOut_pipe_b_task_source;
  reg         pipeOut_pipe_pipe_v;
  reg  [2:0]  pipeOut_pipe_pipe_b_task_opcode;
  reg  [30:0] pipeOut_pipe_pipe_b_task_tag;
  reg  [10:0] pipeOut_pipe_pipe_b_task_set;
  reg  [2:0]  pipeOut_pipe_pipe_b_task_param;
  reg  [3:0]  pipeOut_pipe_pipe_b_task_source;
  wire        _GEN = io_bs_raddr_ready & has_data;
  wire        task_handled =
    has_data ? io_bs_raddr_ready : io_task_ready_0 & io_task_valid;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      bs_busy <= 1'h0;
      back_pressure <= 1'h0;
      beat <= 1'h0;
      s1_task_opcode <= 3'h0;
      s1_task_tag <= 31'h0;
      s1_task_set <= 11'h0;
      s1_task_param <= 3'h0;
      s1_task_source <= 4'h0;
      s1_valid <= 1'h0;
      pipeOut_pipe_v <= 1'h0;
      pipeOut_pipe_pipe_v <= 1'h0;
    end
    else begin
      bs_busy <= ~(_GEN & beat) & (taskWithData | bs_busy);
      back_pressure <= |(_queue_io_count[2:1]);
      if (_GEN)
        beat <= 1'(beat - 1'h1);
      if (task_handled) begin
        s1_task_opcode <= bs_busy ? task_latch_opcode : io_task_bits_opcode;
        s1_task_tag <= bs_busy ? task_latch_tag : io_task_bits_tag;
        s1_task_set <= task_set;
        s1_task_param <= bs_busy ? task_latch_param : io_task_bits_param;
        s1_task_source <= bs_busy ? task_latch_source : io_task_bits_source;
      end
      s1_valid <= task_handled;
      pipeOut_pipe_v <= s1_valid;
      pipeOut_pipe_pipe_v <= pipeOut_pipe_v;
    end
  end // always @(posedge, posedge)
  always @(posedge clock) begin
    if (~bs_busy & io_task_valid) begin
      task_latch_opcode <= io_task_bits_opcode;
      task_latch_tag <= io_task_bits_tag;
      task_latch_set <= io_task_bits_set;
      task_latch_param <= io_task_bits_param;
      task_latch_source <= io_task_bits_source;
      task_latch_way <= io_task_bits_way;
    end
    if (s1_valid) begin
      pipeOut_pipe_b_task_opcode <= s1_task_opcode;
      pipeOut_pipe_b_task_tag <= s1_task_tag;
      pipeOut_pipe_b_task_set <= s1_task_set;
      pipeOut_pipe_b_task_param <= s1_task_param;
      pipeOut_pipe_b_task_source <= s1_task_source;
    end
    if (pipeOut_pipe_v) begin
      pipeOut_pipe_pipe_b_task_opcode <= pipeOut_pipe_b_task_opcode;
      pipeOut_pipe_pipe_b_task_tag <= pipeOut_pipe_b_task_tag;
      pipeOut_pipe_pipe_b_task_set <= pipeOut_pipe_b_task_set;
      pipeOut_pipe_pipe_b_task_param <= pipeOut_pipe_b_task_param;
      pipeOut_pipe_pipe_b_task_source <= pipeOut_pipe_b_task_source;
    end
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:7];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [3:0] i = 4'h0; i < 4'h8; i += 4'h1) begin
          _RANDOM[i[2:0]] = `RANDOM;
        end
        bs_busy = _RANDOM[3'h0][0];
        back_pressure = _RANDOM[3'h0][1];
        beat = _RANDOM[3'h0][2];
        task_latch_opcode = _RANDOM[3'h0][5:3];
        task_latch_tag = {_RANDOM[3'h0][31:6], _RANDOM[3'h1][4:0]};
        task_latch_set = _RANDOM[3'h1][15:5];
        task_latch_param = _RANDOM[3'h1][18:16];
        task_latch_source = _RANDOM[3'h1][22:19];
        task_latch_way = _RANDOM[3'h1][25:23];
        s1_task_opcode = _RANDOM[3'h1][29:27];
        s1_task_tag = {_RANDOM[3'h1][31:30], _RANDOM[3'h2][28:0]};
        s1_task_set = {_RANDOM[3'h2][31:29], _RANDOM[3'h3][7:0]};
        s1_task_param = _RANDOM[3'h3][10:8];
        s1_task_source = _RANDOM[3'h3][14:11];
        s1_valid = _RANDOM[3'h3][20];
        pipeOut_pipe_v = _RANDOM[3'h3][21];
        pipeOut_pipe_b_task_opcode = _RANDOM[3'h3][24:22];
        pipeOut_pipe_b_task_tag = {_RANDOM[3'h3][31:25], _RANDOM[3'h4][23:0]};
        pipeOut_pipe_b_task_set = {_RANDOM[3'h4][31:24], _RANDOM[3'h5][2:0]};
        pipeOut_pipe_b_task_param = _RANDOM[3'h5][5:3];
        pipeOut_pipe_b_task_source = _RANDOM[3'h5][9:6];
        pipeOut_pipe_pipe_v = _RANDOM[3'h5][15];
        pipeOut_pipe_pipe_b_task_opcode = _RANDOM[3'h5][18:16];
        pipeOut_pipe_pipe_b_task_tag = {_RANDOM[3'h5][31:19], _RANDOM[3'h6][17:0]};
        pipeOut_pipe_pipe_b_task_set = _RANDOM[3'h6][28:18];
        pipeOut_pipe_pipe_b_task_param = _RANDOM[3'h6][31:29];
        pipeOut_pipe_pipe_b_task_source = _RANDOM[3'h7][3:0];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        bs_busy = 1'h0;
        back_pressure = 1'h0;
        beat = 1'h0;
        s1_task_opcode = 3'h0;
        s1_task_tag = 31'h0;
        s1_task_set = 11'h0;
        s1_task_param = 3'h0;
        s1_task_source = 4'h0;
        s1_valid = 1'h0;
        pipeOut_pipe_v = 1'h0;
        pipeOut_pipe_pipe_v = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  Queue7_TLBundleC queue (
    .clock               (clock),
    .reset               (reset),
    .io_enq_valid        (pipeOut_pipe_pipe_v),
    .io_enq_bits_opcode  (pipeOut_pipe_pipe_b_task_opcode),
    .io_enq_bits_param   (pipeOut_pipe_pipe_b_task_param),
    .io_enq_bits_source  (pipeOut_pipe_pipe_b_task_source),
    .io_enq_bits_address
      ({pipeOut_pipe_pipe_b_task_tag, pipeOut_pipe_pipe_b_task_set, 6'h0}),
    .io_enq_bits_data    (io_bs_rdata_data),
    .io_enq_bits_corrupt (io_bs_rdata_corrupt),
    .io_deq_ready        (io_c_ready),
    .io_deq_valid        (io_c_valid),
    .io_deq_bits_opcode  (io_c_bits_opcode),
    .io_deq_bits_param   (io_c_bits_param),
    .io_deq_bits_size    (io_c_bits_size),
    .io_deq_bits_source  (io_c_bits_source),
    .io_deq_bits_address (io_c_bits_address),
    .io_deq_bits_data    (io_c_bits_data),
    .io_deq_bits_corrupt (io_c_bits_corrupt),
    .io_count            (_queue_io_count)
  );
  assign io_bs_raddr_valid = has_data;
  assign io_bs_raddr_bits_way = bs_busy ? task_latch_way : io_task_bits_way;
  assign io_bs_raddr_bits_set = task_set;
  assign io_bs_raddr_bits_beat = beat;
  assign io_task_ready = io_task_ready_0;
endmodule

