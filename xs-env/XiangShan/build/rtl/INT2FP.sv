// Generated by CIRCT firtool-1.62.1
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

module INT2FP(
  input         clock,
  input         reset,
  input         io_fire,
  input  [63:0] io_src,
  input  [7:0]  io_opType,
  input  [2:0]  io_rm,
  input  [3:0]  io_input1H,
  input  [3:0]  io_output1H,
  output [63:0] io_result,
  output [4:0]  io_fflags
);

  wire         _rounder_io_inexact;
  wire         _rounder_io_r_up;
  wire [6:0]   _leadZerosNext_clz_io_out;
  reg          fireReg_last_r;
  reg  [3:0]   output1HReg;
  wire [64:0]  input_0 =
    (io_input1H[0] ? {{57{io_opType[0] & io_src[7]}}, io_src[7:0]} : 65'h0)
    | (io_input1H[1] ? {{49{io_opType[0] & io_src[15]}}, io_src[15:0]} : 65'h0)
    | (io_input1H[2] ? {{33{io_opType[0] & io_src[31]}}, io_src[31:0]} : 65'h0)
    | (io_input1H[3] ? {io_opType[0] & io_src[63], io_src} : 65'h0);
  reg          signSrc;
  reg  [2:0]   rm;
  wire [63:0]  absIntSrcNext =
    input_0[64] ? 64'(~(input_0[63:0]) + 64'h1) : input_0[63:0];
  reg          isZeroIntSrc;
  reg  [12:0]  expAdderIn0;
  reg  [12:0]  expAdderIn1;
  reg  [63:0]  absIntSrc;
  reg  [6:0]   leadZeros;
  wire [191:0] _shiftLeft_T_1 = {127'h0, absIntSrc, 1'h0} << leadZeros;
  wire [51:0]  rounderInput =
    {29'h0,
     {13'h0, output1HReg[1] ? _shiftLeft_T_1[63:54] : 10'h0}
       | (output1HReg[2] ? _shiftLeft_T_1[63:41] : 23'h0)}
    | (output1HReg[3] ? _shiftLeft_T_1[63:12] : 52'h0);
  reg  [4:0]   fflags;
  reg  [63:0]  result;
  wire [12:0]  _exp_T = 13'(expAdderIn0 + expAdderIn1);
  wire         cout =
    _rounder_io_r_up
    & (output1HReg[1] & (&(_shiftLeft_T_1[63:54])) | output1HReg[2]
       & (&(_shiftLeft_T_1[63:41])) | output1HReg[3] & (&(_shiftLeft_T_1[63:12])));
  wire [10:0]  _expRounded_T = cout ? 11'(_exp_T[10:0] + 11'h1) : _exp_T[10:0];
  wire [51:0]  fracRounded = _rounder_io_r_up ? 52'(rounderInput + 52'h1) : rounderInput;
  wire         rmin = rm == 3'h1 | signSrc & rm == 3'h3 | ~signSrc & rm == 3'h2;
  wire         of =
    ~(_exp_T[12])
    & (output1HReg[1]
       & (cout
            ? (&(_exp_T[4:1])) | (|(_exp_T[11:5]))
            : (&(_exp_T[4:0])) | (|(_exp_T[11:5]))) | output1HReg[2]
       & (cout
            ? (&(_exp_T[7:1])) | (|(_exp_T[11:8]))
            : (&(_exp_T[7:0])) | (|(_exp_T[11:8]))) | output1HReg[3]
       & (cout ? (&(_exp_T[10:1])) | _exp_T[11] : (&(_exp_T[10:0])) | _exp_T[11]));
  wire         _result1H_T = of & rmin;
  wire         _result1H_T_2 = of & ~rmin;
  wire         _result1H_T_5 = ~of & ~isZeroIntSrc;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      fireReg_last_r <= 1'h0;
      output1HReg <= 4'h0;
      signSrc <= 1'h0;
      rm <= 3'h0;
      isZeroIntSrc <= 1'h0;
      fflags <= 5'h0;
      result <= 64'h0;
    end
    else begin
      if (io_fire | fireReg_last_r)
        fireReg_last_r <= io_fire;
      if (io_fire) begin
        output1HReg <= io_output1H;
        signSrc <= input_0[64];
        rm <= io_rm;
        isZeroIntSrc <= absIntSrcNext == 64'h0;
      end
      if (fireReg_last_r) begin
        fflags <= {2'h0, of, 1'h0, of | _rounder_io_inexact};
        result <=
          {32'h0,
           {16'h0,
            output1HReg[1]
              ? (_result1H_T ? {signSrc, 15'h7BFF} : 16'h0)
                | (_result1H_T_2 ? {signSrc, 15'h7C00} : 16'h0)
                | (isZeroIntSrc ? {signSrc, 15'h0} : 16'h0)
                | (_result1H_T_5
                     ? {signSrc, _expRounded_T[4:0], fracRounded[9:0]}
                     : 16'h0)
              : 16'h0}
             | (output1HReg[2]
                  ? (_result1H_T ? {signSrc, 31'h7F7FFFFF} : 32'h0)
                    | (_result1H_T_2 ? {signSrc, 31'h7F800000} : 32'h0)
                    | (isZeroIntSrc ? {signSrc, 31'h0} : 32'h0)
                    | (_result1H_T_5
                         ? {signSrc, _expRounded_T[7:0], fracRounded[22:0]}
                         : 32'h0)
                  : 32'h0)}
          | (output1HReg[3]
               ? (_result1H_T ? {signSrc, 63'h7FEFFFFFFFFFFFFF} : 64'h0)
                 | (_result1H_T_2 ? {signSrc, 63'h7FF0000000000000} : 64'h0)
                 | (isZeroIntSrc ? {signSrc, 63'h0} : 64'h0)
                 | (_result1H_T_5 ? {signSrc, _expRounded_T, fracRounded} : 64'h0)
               : 64'h0);
      end
    end
  end // always @(posedge, posedge)
  wire [7:0]   _minusExp_T_2 = 8'({1'h1, ~_leadZerosNext_clz_io_out} + 8'h1);
  always @(posedge clock) begin
    if (io_fire) begin
      expAdderIn0 <=
        {2'h0,
         {3'h0, {1'h0, io_output1H[1] ? 7'h4E : 7'h0} | (io_output1H[2] ? 8'hBE : 8'h0)}
           | (io_output1H[3] ? 11'h43E : 11'h0)};
      expAdderIn1 <= {{5{_minusExp_T_2[7]}}, _minusExp_T_2};
      absIntSrc <= absIntSrcNext;
      leadZeros <= _leadZerosNext_clz_io_out;
    end
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:5];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [2:0] i = 3'h0; i < 3'h6; i += 3'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        fireReg_last_r = _RANDOM[3'h0][0];
        output1HReg = _RANDOM[3'h0][4:1];
        signSrc = _RANDOM[3'h0][5];
        rm = _RANDOM[3'h0][8:6];
        isZeroIntSrc = _RANDOM[3'h0][9];
        expAdderIn0 = _RANDOM[3'h0][22:10];
        expAdderIn1 = {_RANDOM[3'h0][31:23], _RANDOM[3'h1][3:0]};
        absIntSrc = {_RANDOM[3'h1][31:4], _RANDOM[3'h2], _RANDOM[3'h3][3:0]};
        leadZeros = _RANDOM[3'h3][10:4];
        fflags = _RANDOM[3'h3][15:11];
        result = {_RANDOM[3'h3][31:16], _RANDOM[3'h4], _RANDOM[3'h5][15:0]};
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        fireReg_last_r = 1'h0;
        output1HReg = 4'h0;
        signSrc = 1'h0;
        rm = 3'h0;
        isZeroIntSrc = 1'h0;
        fflags = 5'h0;
        result = 64'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  CLZ_6 leadZerosNext_clz (
    .io_in  (absIntSrcNext),
    .io_out (_leadZerosNext_clz_io_out)
  );
  RoundingUnit_3 rounder (
    .io_in       ({12'h0, rounderInput}),
    .io_roundIn
      (output1HReg[1] & _shiftLeft_T_1[53] | output1HReg[2] & _shiftLeft_T_1[40]
       | output1HReg[3] & _shiftLeft_T_1[11]),
    .io_stickyIn
      (output1HReg[1] & (|(_shiftLeft_T_1[52:0])) | output1HReg[2]
       & (|(_shiftLeft_T_1[39:0])) | output1HReg[3] & (|(_shiftLeft_T_1[10:0]))),
    .io_signIn   (signSrc),
    .io_rm       (rm),
    .io_inexact  (_rounder_io_inexact),
    .io_r_up     (_rounder_io_r_up)
  );
  assign io_result = result;
  assign io_fflags = fflags;
endmodule

