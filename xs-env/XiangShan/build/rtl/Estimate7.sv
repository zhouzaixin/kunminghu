// Generated by CIRCT firtool-1.62.1
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

module Estimate7(
  input         clock,
  input         reset,
  input         io_fire,
  input  [63:0] io_src,
  input  [7:0]  io_opType,
  input  [2:0]  io_rm,
  input  [3:0]  io_input1H,
  input  [3:0]  io_output1H,
  output [63:0] io_result,
  output [4:0]  io_fflags
);

  wire [6:0]   _rec7Table_out;
  wire [6:0]   _rsqrt7Table_out;
  wire [6:0]   _leadZerosNext_clz_io_out;
  reg          fireReg_last_r;
  wire [63:0]  input_0 =
    (io_input1H[1] ? {io_src[15], 6'h0, io_src[14:0], 42'h0} : 64'h0)
    | (io_input1H[2] ? {io_src[31], 3'h0, io_src[30:0], 29'h0} : 64'h0)
    | (io_input1H[3] ? io_src : 64'h0);
  wire         isRecNext = io_opType[5] & io_opType[0];
  reg  [2:0]   rm;
  wire [2:0]   decodeFloatSrc =
    (io_input1H[1] ? {|(input_0[51:42]), &(input_0[56:52]), |(input_0[56:52])} : 3'h0)
    | (io_input1H[2] ? {|(input_0[51:29]), &(input_0[59:52]), |(input_0[59:52])} : 3'h0)
    | (io_input1H[3] ? {|(input_0[51:0]), &(input_0[62:52]), |(input_0[62:52])} : 3'h0);
  wire         isSubnormalSrcNext = ~(decodeFloatSrc[0]) & decodeFloatSrc[2];
  reg          expIsOnesSrc;
  reg          isSubnormalSrc;
  reg          isRec;
  reg          isSNaNSrc;
  reg          signSrc;
  reg          isZeroSrc;
  reg          isQNaNSrc;
  reg          isSubnormalRec2;
  reg          isInfSrc;
  reg          isNaNSrc;
  reg          isNormalRec0;
  reg          isNormalRec1;
  reg          isNormalRec2;
  reg          isSubnormalRec0;
  reg          isSubnormalRec1;
  reg  [3:0]   output1HReg;
  reg  [4:0]   fflags;
  reg  [63:0]  result;
  wire [63:0]  clzIn = {input_0[51:0], 12'h0};
  reg  [12:0]  expAdderIn0;
  reg  [12:0]  expAdderIn1;
  reg          expNormaled0;
  reg  [63:0]  fracSrcLeft;
  reg  [6:0]   leadZeros;
  wire [191:0] _shiftLeft_T_1 = {127'h0, fracSrcLeft, 1'h0} << leadZeros;
  wire [6:0]   fracNormaled = isSubnormalSrc ? _shiftLeft_T_1[63:57] : fracSrcLeft[63:57];
  wire         isNaNSrcNext = decodeFloatSrc[1] & decodeFloatSrc[2];
  wire [1:0]   decodeFloatSrcRec =
    (io_input1H[1]
       ? {(&(input_0[56:54])) & ~(input_0[53]) & input_0[52],
          (&(input_0[56:53])) & ~(input_0[52])}
       : 2'h0)
    | (io_input1H[2]
         ? {(&(input_0[59:54])) & ~(input_0[53]) & input_0[52],
            (&(input_0[59:53])) & ~(input_0[52])}
         : 2'h0)
    | (io_input1H[3]
         ? {(&(input_0[62:54])) & ~(input_0[53]) & input_0[52],
            (&(input_0[62:53])) & ~(input_0[52])}
         : 2'h0);
  wire         rmin = rm == 3'h1 | signSrc & rm == 3'h3 | ~signSrc & rm == 3'h2;
  wire [11:0]  _exp_T = 12'(expAdderIn0[11:0] + expAdderIn1[11:0]);
  wire [6:0]   fracEstimate = isRec ? _rec7Table_out : _rsqrt7Table_out;
  wire         nx = isRec & isSubnormalRec2;
  wire         _recResult1H_T_2 = isZeroSrc | isSubnormalRec2 & ~rmin;
  wire         _recResult1H_T_4 = isNormalRec2 | isSubnormalRec0 | isSubnormalRec1;
  wire         _recResult1H_T_5 = isSubnormalRec2 & rmin;
  wire         _sqrtResult1H_T_2 = signSrc & ~isZeroSrc | isNaNSrc;
  wire         _sqrtResult1H_T_7 = ~signSrc & ~isZeroSrc & ~expIsOnesSrc;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      fireReg_last_r <= 1'h0;
      rm <= 3'h0;
      expIsOnesSrc <= 1'h0;
      isSubnormalSrc <= 1'h0;
      isRec <= 1'h0;
      isSNaNSrc <= 1'h0;
      signSrc <= 1'h0;
      isZeroSrc <= 1'h0;
      isQNaNSrc <= 1'h0;
      isSubnormalRec2 <= 1'h0;
      isInfSrc <= 1'h0;
      isNaNSrc <= 1'h0;
      isNormalRec0 <= 1'h0;
      isNormalRec1 <= 1'h0;
      isNormalRec2 <= 1'h0;
      isSubnormalRec0 <= 1'h0;
      isSubnormalRec1 <= 1'h0;
      output1HReg <= 4'h0;
      fflags <= 5'h0;
      result <= 64'h0;
      expNormaled0 <= 1'h0;
      fracSrcLeft <= 64'h0;
    end
    else begin
      if (io_fire | fireReg_last_r)
        fireReg_last_r <= io_fire;
      if (io_fire) begin
        rm <= io_rm;
        expIsOnesSrc <= decodeFloatSrc[1];
        isSubnormalSrc <= isSubnormalSrcNext;
        isRec <= isRecNext;
        isSNaNSrc <= isNaNSrcNext & ~(input_0[51]);
        signSrc <= input_0[63];
        isZeroSrc <= ~(decodeFloatSrc[0]) & ~(decodeFloatSrc[2]);
        isQNaNSrc <= isNaNSrcNext & input_0[51];
        isSubnormalRec2 <= isSubnormalSrcNext & input_0[51:50] == 2'h0;
        isInfSrc <= decodeFloatSrc[1] & ~(decodeFloatSrc[2]);
        isNaNSrc <= isNaNSrcNext;
        isNormalRec0 <= decodeFloatSrcRec[0];
        isNormalRec1 <= decodeFloatSrcRec[1];
        isNormalRec2 <=
          decodeFloatSrc[0] & ~(decodeFloatSrc[1]) & ~(decodeFloatSrcRec[0])
          & ~(decodeFloatSrcRec[1]);
        isSubnormalRec0 <= isSubnormalSrcNext & input_0[51];
        isSubnormalRec1 <= isSubnormalSrcNext & ~(input_0[51]) & input_0[50];
        output1HReg <= io_output1H;
        expNormaled0 <= isSubnormalSrcNext ? _leadZerosNext_clz_io_out[0] : input_0[52];
        fracSrcLeft <= clzIn;
      end
      if (fireReg_last_r) begin
        fflags <=
          {~isRec & signSrc & ~isZeroSrc & ~isQNaNSrc | isSNaNSrc,
           isZeroSrc,
           nx,
           1'h0,
           nx};
        result <=
          isRec
            ? {32'h0,
               {16'h0,
                output1HReg[1]
                  ? (isNaNSrc ? 16'h7E00 : 16'h0) | (isInfSrc ? {signSrc, 15'h0} : 16'h0)
                    | (_recResult1H_T_2 ? {signSrc, 15'h7C00} : 16'h0)
                    | (isNormalRec0 ? {signSrc, 7'h1, fracEstimate, 1'h0} : 16'h0)
                    | (isNormalRec1 ? {signSrc, 6'h1, fracEstimate, 2'h0} : 16'h0)
                    | (_recResult1H_T_4
                         ? {signSrc, _exp_T[4:0], fracEstimate, 3'h0}
                         : 16'h0) | (_recResult1H_T_5 ? {signSrc, 15'h7BFF} : 16'h0)
                  : 16'h0}
                 | (output1HReg[2]
                      ? (isNaNSrc ? 32'h7FC00000 : 32'h0)
                        | (isInfSrc ? {signSrc, 31'h0} : 32'h0)
                        | (_recResult1H_T_2 ? {signSrc, 31'h7F800000} : 32'h0)
                        | (isNormalRec0 ? {signSrc, 10'h1, fracEstimate, 14'h0} : 32'h0)
                        | (isNormalRec1 ? {signSrc, 9'h1, fracEstimate, 15'h0} : 32'h0)
                        | (_recResult1H_T_4
                             ? {signSrc, _exp_T[7:0], fracEstimate, 16'h0}
                             : 32'h0)
                        | (_recResult1H_T_5 ? {signSrc, 31'h7F7FFFFF} : 32'h0)
                      : 32'h0)}
              | (output1HReg[3]
                   ? (isNaNSrc ? 64'h7FF8000000000000 : 64'h0)
                     | (isInfSrc ? {signSrc, 63'h0} : 64'h0)
                     | (_recResult1H_T_2 ? {signSrc, 63'h7FF0000000000000} : 64'h0)
                     | (isNormalRec0 ? {signSrc, 13'h1, fracEstimate, 43'h0} : 64'h0)
                     | (isNormalRec1 ? {signSrc, 12'h1, fracEstimate, 44'h0} : 64'h0)
                     | (_recResult1H_T_4
                          ? {signSrc, _exp_T[10:0], fracEstimate, 45'h0}
                          : 64'h0)
                     | (_recResult1H_T_5 ? {signSrc, 63'h7FEFFFFFFFFFFFFF} : 64'h0)
                   : 64'h0)
            : {32'h0,
               {16'h0,
                output1HReg[1]
                  ? (_sqrtResult1H_T_2 ? 16'h7E00 : 16'h0)
                    | (isZeroSrc ? {signSrc, 15'h7C00} : 16'h0)
                    | (_sqrtResult1H_T_7
                         ? {signSrc, _exp_T[5:1], fracEstimate, 3'h0}
                         : 16'h0)
                  : 16'h0}
                 | (output1HReg[2]
                      ? (_sqrtResult1H_T_2 ? 32'h7FC00000 : 32'h0)
                        | (isZeroSrc ? {signSrc, 31'h7F800000} : 32'h0)
                        | (_sqrtResult1H_T_7
                             ? {signSrc, _exp_T[8:1], fracEstimate, 16'h0}
                             : 32'h0)
                      : 32'h0)}
              | (output1HReg[3]
                   ? (_sqrtResult1H_T_2 ? 64'h7FF8000000000000 : 64'h0)
                     | (isZeroSrc ? {signSrc, 63'h7FF0000000000000} : 64'h0)
                     | (_sqrtResult1H_T_7
                          ? {signSrc, _exp_T[11:1], fracEstimate, 45'h0}
                          : 64'h0)
                   : 64'h0);
      end
    end
  end // always @(posedge, posedge)
  wire [11:0]  _minusExp_T_2 = 12'({1'h1, ~(input_0[62:52])} + 12'h1);
  always @(posedge clock) begin
    if (io_fire) begin
      expAdderIn0 <=
        {1'h0,
         {3'h0,
          {3'h0, io_output1H[1] ? (isRecNext ? 6'h1D : 6'h2C) : 6'h0}
            | (io_output1H[2] ? (isRecNext ? 9'hFD : 9'h17C) : 9'h0)}
           | (io_output1H[3] ? (isRecNext ? 12'h7FD : 12'hBFC) : 12'h0)};
      expAdderIn1 <=
        isSubnormalSrcNext
          ? {6'h0, _leadZerosNext_clz_io_out}
          : {_minusExp_T_2[11], _minusExp_T_2};
      leadZeros <= _leadZerosNext_clz_io_out;
    end
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:5];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [2:0] i = 3'h0; i < 3'h6; i += 3'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        fireReg_last_r = _RANDOM[3'h0][0];
        rm = _RANDOM[3'h0][3:1];
        expIsOnesSrc = _RANDOM[3'h0][4];
        isSubnormalSrc = _RANDOM[3'h0][5];
        isRec = _RANDOM[3'h0][6];
        isSNaNSrc = _RANDOM[3'h0][7];
        signSrc = _RANDOM[3'h0][8];
        isZeroSrc = _RANDOM[3'h0][9];
        isQNaNSrc = _RANDOM[3'h0][10];
        isSubnormalRec2 = _RANDOM[3'h0][11];
        isInfSrc = _RANDOM[3'h0][12];
        isNaNSrc = _RANDOM[3'h0][13];
        isNormalRec0 = _RANDOM[3'h0][14];
        isNormalRec1 = _RANDOM[3'h0][15];
        isNormalRec2 = _RANDOM[3'h0][16];
        isSubnormalRec0 = _RANDOM[3'h0][17];
        isSubnormalRec1 = _RANDOM[3'h0][18];
        output1HReg = _RANDOM[3'h0][22:19];
        fflags = _RANDOM[3'h0][27:23];
        result = {_RANDOM[3'h0][31:28], _RANDOM[3'h1], _RANDOM[3'h2][27:0]};
        expAdderIn0 = {_RANDOM[3'h2][31:28], _RANDOM[3'h3][8:0]};
        expAdderIn1 = _RANDOM[3'h3][21:9];
        expNormaled0 = _RANDOM[3'h3][22];
        fracSrcLeft = {_RANDOM[3'h3][31:23], _RANDOM[3'h4], _RANDOM[3'h5][22:0]};
        leadZeros = _RANDOM[3'h5][29:23];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        fireReg_last_r = 1'h0;
        rm = 3'h0;
        expIsOnesSrc = 1'h0;
        isSubnormalSrc = 1'h0;
        isRec = 1'h0;
        isSNaNSrc = 1'h0;
        signSrc = 1'h0;
        isZeroSrc = 1'h0;
        isQNaNSrc = 1'h0;
        isSubnormalRec2 = 1'h0;
        isInfSrc = 1'h0;
        isNaNSrc = 1'h0;
        isNormalRec0 = 1'h0;
        isNormalRec1 = 1'h0;
        isNormalRec2 = 1'h0;
        isSubnormalRec0 = 1'h0;
        isSubnormalRec1 = 1'h0;
        output1HReg = 4'h0;
        fflags = 5'h0;
        result = 64'h0;
        expNormaled0 = 1'h0;
        fracSrcLeft = 64'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  CLZ_6 leadZerosNext_clz (
    .io_in  (clzIn),
    .io_out (_leadZerosNext_clz_io_out)
  );
  Rsqrt7Table rsqrt7Table (
    .src ({expNormaled0, fracNormaled[6:1]}),
    .out (_rsqrt7Table_out)
  );
  Rec7Table rec7Table (
    .src (fracNormaled),
    .out (_rec7Table_out)
  );
  assign io_result = result;
  assign io_fflags = fflags;
endmodule

