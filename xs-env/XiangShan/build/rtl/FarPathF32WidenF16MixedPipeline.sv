// Generated by CIRCT firtool-1.62.1
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

module FarPathF32WidenF16MixedPipeline(
  input         clock,
  input         io_fire,
  input  [31:0] io_fp_a,
  input  [31:0] io_fp_b,
  output [31:0] io_fp_c,
  input         io_is_sub,
  input  [2:0]  io_round_mode,
  output [4:0]  io_fflags,
  output [7:0]  io_absEaSubEb,
  input         io_res_is_f32,
  output        io_isEfp_bGreater
);

  wire        NX;
  wire        OF_reg;
  wire [24:0] _U_FS1_io_result;
  wire [24:0] _U_FS0_io_result;
  wire [51:0] _U_far_rshift_2_io_result;
  wire [51:0] _U_far_rshift_1_io_result;
  wire [7:0]  _U_Efp_bSubEfp_a_io_c;
  wire [7:0]  _U_Efp_aSubEfp_b_io_c;
  reg         res_is_f32_reg;
  wire        efficient_fp_b_sign = io_fp_b[31] ^ io_is_sub;
  wire        EOP = io_fp_a[31] ^ efficient_fp_b_sign;
  reg         RNE_reg;
  reg         RTZ_reg;
  reg         RDN_reg;
  reg         RUP_reg;
  reg         RMM_reg;
  wire        _GEN = io_fp_a[23] | ~(|(io_fp_a[30:23]));
  wire        _GEN_0 = io_fp_b[23] | ~(|(io_fp_b[30:23]));
  wire        isEfp_bGreater = io_fp_b[30:23] > io_fp_a[30:23];
  wire [7:0]  absEaSubEb = isEfp_bGreater ? _U_Efp_bSubEfp_a_io_c : _U_Efp_aSubEfp_b_io_c;
  wire [23:0] significand_fp_a = {|(io_fp_a[30:23]), io_fp_a[22:0]};
  wire [23:0] significand_fp_b = {|(io_fp_b[30:23]), io_fp_b[22:0]};
  wire [23:0] greaterSignificand = isEfp_bGreater ? significand_fp_b : significand_fp_a;
  wire [24:0] A = EOP ? {greaterSignificand, 1'h0} : {1'h0, greaterSignificand};
  wire [51:0] far_rshift_widen_result =
    isEfp_bGreater ? _U_far_rshift_2_io_result : _U_far_rshift_1_io_result;
  wire        absEaSubEb_is_greater =
    io_res_is_f32 ? absEaSubEb > 8'h1B : absEaSubEb > 8'hE;
  wire [24:0] B = absEaSubEb_is_greater ? {25{EOP}} : far_rshift_widen_result[51:27];
  wire        FS0_0_reg = res_is_f32_reg ? _U_FS0_io_result[0] : _U_FS0_io_result[13];
  wire        FS0_1_reg = res_is_f32_reg ? _U_FS0_io_result[1] : _U_FS0_io_result[14];
  reg  [1:0]  lgs_normal_reg_r;
  reg         far_sign_result_reg;
  reg         far_case_normal_round_up_reg_r;
  wire        _far_case_overflow_round_up_reg_T_13 = RDN_reg & far_sign_result_reg;
  wire        far_case_normal_round_up_reg =
    far_case_normal_round_up_reg_r & ~(lgs_normal_reg_r[1]) & ~(lgs_normal_reg_r[0])
    | RNE_reg & lgs_normal_reg_r[1] & (FS0_0_reg | lgs_normal_reg_r[0])
    | _far_case_overflow_round_up_reg_T_13 & (|lgs_normal_reg_r) | RUP_reg
    & ~far_sign_result_reg & (|lgs_normal_reg_r) | RMM_reg & lgs_normal_reg_r[1];
  reg  [2:0]  grs_overflow_reg;
  wire        _lgs_overflow_reg_T_3 = grs_overflow_reg[1] | grs_overflow_reg[0];
  reg         far_case_overflow_round_up_reg_r;
  wire        far_case_overflow_round_up_reg =
    far_case_overflow_round_up_reg_r & ~(grs_overflow_reg[2]) & ~_lgs_overflow_reg_T_3
    | RNE_reg & grs_overflow_reg[2] & (FS0_1_reg | _lgs_overflow_reg_T_3)
    | _far_case_overflow_round_up_reg_T_13 & (grs_overflow_reg[2] | _lgs_overflow_reg_T_3)
    | RUP_reg & ~far_sign_result_reg & (grs_overflow_reg[2] | _lgs_overflow_reg_T_3)
    | RMM_reg & grs_overflow_reg[2];
  reg         far_exponent_result_reg_r;
  reg  [7:0]  far_exponent_result_reg_r_1;
  reg  [7:0]  far_exponent_result_reg_r_2;
  reg         OF_reg_r;
  assign OF_reg =
    OF_reg_r
    & (_U_FS0_io_result[24] | _U_FS1_io_result[24] & FS0_0_reg
       & far_case_normal_round_up_reg);
  assign NX =
    (_U_FS0_io_result[24]
       ? (|{grs_overflow_reg[2], _lgs_overflow_reg_T_3})
       : (|lgs_normal_reg_r)) | OF_reg;
  wire [7:0]  E_greater = isEfp_bGreater ? io_fp_b[30:23] : io_fp_a[30:23];
  wire [7:0]  EA = EOP ? 8'(E_greater - 8'h1) : E_greater;
  wire [7:0]  _EA_add1_T = 8'(EA + 8'h1);
  wire        B_guard_normal =
    ~absEaSubEb_is_greater
    & (EOP
         ? (io_res_is_f32
              ? ~(far_rshift_widen_result[26])
              : ~(far_rshift_widen_result[39]))
         : io_res_is_f32 ? far_rshift_widen_result[26] : far_rshift_widen_result[39]);
  wire        B_rsticky_normal =
    ~absEaSubEb_is_greater
    & (EOP
         ? (io_res_is_f32
              ? ~(far_rshift_widen_result[25])
              : ~(far_rshift_widen_result[38]))
         : io_res_is_f32 ? far_rshift_widen_result[25] : far_rshift_widen_result[38])
    | (absEaSubEb_is_greater
         ? (|(isEfp_bGreater ? significand_fp_a : significand_fp_b))
         : EOP
             ? (io_res_is_f32
                  ? far_rshift_widen_result[24:0] != 25'h1FFFFFF
                  : far_rshift_widen_result[37:0] != 38'h3FFFFFFFFF)
             : io_res_is_f32
                 ? (|(far_rshift_widen_result[24:0]))
                 : (|(far_rshift_widen_result[37:0])));
  wire [1:0]  _lgs_normal_reg_T_4 = {B_guard_normal, B_rsticky_normal};
  wire        A_0 = io_res_is_f32 ? A[0] : A[13];
  wire        B_0 = io_res_is_f32 ? B[0] : B[13];
  always @(posedge clock) begin
    if (io_fire) begin
      res_is_f32_reg <= io_res_is_f32;
      RNE_reg <= io_round_mode == 3'h0;
      RTZ_reg <= io_round_mode == 3'h1;
      RDN_reg <= io_round_mode == 3'h2;
      RUP_reg <= io_round_mode == 3'h3;
      RMM_reg <= io_round_mode == 3'h4;
      lgs_normal_reg_r <= EOP ? 2'(~_lgs_normal_reg_T_4 + 2'h1) : _lgs_normal_reg_T_4;
      far_sign_result_reg <= isEfp_bGreater ? efficient_fp_b_sign : io_fp_a[31];
      far_case_normal_round_up_reg_r <= EOP;
      grs_overflow_reg <=
        EOP
          ? 3'({A_0, 2'h0} - {~B_0, B_guard_normal, B_rsticky_normal})
          : {A_0 ^ B_0, B_guard_normal, B_rsticky_normal};
      far_case_overflow_round_up_reg_r <= EOP;
      far_exponent_result_reg_r <= EA == 8'h0;
      far_exponent_result_reg_r_1 <= _EA_add1_T;
      far_exponent_result_reg_r_2 <= EA;
      OF_reg_r <= io_res_is_f32 ? (&_EA_add1_T) : (&(_EA_add1_T[4:0]));
    end
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        res_is_f32_reg = _RANDOM[/*Zero width*/ 1'b0][0];
        RNE_reg = _RANDOM[/*Zero width*/ 1'b0][1];
        RTZ_reg = _RANDOM[/*Zero width*/ 1'b0][2];
        RDN_reg = _RANDOM[/*Zero width*/ 1'b0][3];
        RUP_reg = _RANDOM[/*Zero width*/ 1'b0][4];
        RMM_reg = _RANDOM[/*Zero width*/ 1'b0][5];
        lgs_normal_reg_r = _RANDOM[/*Zero width*/ 1'b0][7:6];
        far_sign_result_reg = _RANDOM[/*Zero width*/ 1'b0][8];
        far_case_normal_round_up_reg_r = _RANDOM[/*Zero width*/ 1'b0][9];
        grs_overflow_reg = _RANDOM[/*Zero width*/ 1'b0][12:10];
        far_case_overflow_round_up_reg_r = _RANDOM[/*Zero width*/ 1'b0][13];
        far_exponent_result_reg_r = _RANDOM[/*Zero width*/ 1'b0][14];
        far_exponent_result_reg_r_1 = _RANDOM[/*Zero width*/ 1'b0][22:15];
        far_exponent_result_reg_r_2 = _RANDOM[/*Zero width*/ 1'b0][30:23];
        OF_reg_r = _RANDOM[/*Zero width*/ 1'b0][31];
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  Adder_2 U_Efp_aSubEfp_b (
    .io_a ({io_fp_a[30:24], _GEN}),
    .io_b ({io_fp_b[30:24], _GEN_0}),
    .io_c (_U_Efp_aSubEfp_b_io_c)
  );
  Adder_2 U_Efp_bSubEfp_a (
    .io_a ({io_fp_b[30:24], _GEN_0}),
    .io_b ({io_fp_a[30:24], _GEN}),
    .io_c (_U_Efp_bSubEfp_a_io_c)
  );
  FarShiftRightWithMuxInvFirst_2 U_far_rshift_1 (
    .io_src
      (EOP
         ? {~significand_fp_b, 28'hFFFFFFF}
         : {1'h0, |(io_fp_b[30:23]), io_fp_b[22:0], 27'h0}),
    .io_shiftValue (_U_Efp_aSubEfp_b_io_c[4:0]),
    .io_result     (_U_far_rshift_1_io_result),
    .io_EOP        (EOP)
  );
  FarShiftRightWithMuxInvFirst_2 U_far_rshift_2 (
    .io_src
      (EOP
         ? {~significand_fp_a, 28'hFFFFFFF}
         : {1'h0, |(io_fp_a[30:23]), io_fp_a[22:0], 27'h0}),
    .io_shiftValue (_U_Efp_bSubEfp_a_io_c[4:0]),
    .io_result     (_U_far_rshift_2_io_result),
    .io_EOP        (EOP)
  );
  FarPathF32WidenF16MixedAdderPipeline U_FS0 (
    .clock     (clock),
    .io_fire   (io_fire),
    .io_A      (A),
    .io_B      (B),
    .io_result (_U_FS0_io_result)
  );
  FarPathF32WidenF16MixedAdderPipeline U_FS1 (
    .clock     (clock),
    .io_fire   (io_fire),
    .io_A      (25'(A + {10'h0, io_res_is_f32 ? 15'h2 : 15'h4000})),
    .io_B      (B),
    .io_result (_U_FS1_io_result)
  );
  assign io_fp_c =
    {far_sign_result_reg,
     OF_reg
       ? (RTZ_reg | RDN_reg & ~far_sign_result_reg | RUP_reg & far_sign_result_reg
            ? 31'h7F7FFFFF
            : 31'h7F800000)
       : {_U_FS0_io_result[24] | _U_FS1_io_result[24] & FS0_0_reg
          & far_case_normal_round_up_reg | far_exponent_result_reg_r
          & _U_FS0_io_result[23]
            ? far_exponent_result_reg_r_1
            : far_exponent_result_reg_r_2,
          (~(_U_FS0_io_result[24])
           & (~FS0_0_reg & far_case_normal_round_up_reg | ~far_case_normal_round_up_reg)
             ? {_U_FS0_io_result[22:14],
                ~res_is_f32_reg & far_case_normal_round_up_reg ^ _U_FS0_io_result[13],
                _U_FS0_io_result[12:1],
                FS0_0_reg ^ far_case_normal_round_up_reg}
             : 23'h0)
            | (~(_U_FS0_io_result[24]) & FS0_0_reg & far_case_normal_round_up_reg
                 ? {_U_FS1_io_result[22:14],
                    res_is_f32_reg & _U_FS1_io_result[13],
                    _U_FS1_io_result[12:1],
                    1'h0}
                 : 23'h0)
            | (_U_FS0_io_result[24]
               & (~FS0_1_reg & far_case_overflow_round_up_reg
                  | ~far_case_overflow_round_up_reg)
                 ? {_U_FS0_io_result[23:15],
                    ~res_is_f32_reg & far_case_overflow_round_up_reg
                      ^ _U_FS0_io_result[14],
                    _U_FS0_io_result[13:2],
                    FS0_1_reg ^ far_case_overflow_round_up_reg}
                 : 23'h0)
            | (_U_FS0_io_result[24] & FS0_1_reg & far_case_overflow_round_up_reg
                 ? _U_FS1_io_result[23:1]
                 : 23'h0)}};
  assign io_fflags = {2'h0, OF_reg, 1'h0, NX};
  assign io_absEaSubEb = absEaSubEb;
  assign io_isEfp_bGreater = isEfp_bGreater;
endmodule

