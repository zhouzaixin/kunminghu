// Generated by CIRCT firtool-1.62.1
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

module FarPathF16Pipeline(
  input         clock,
  input         io_fire,
  input  [15:0] io_fp_a,
  input  [15:0] io_fp_b,
  output [15:0] io_fp_c,
  input         io_is_sub,
  input  [2:0]  io_round_mode,
  output [4:0]  io_fflags,
  output [4:0]  io_absEaSubEb,
  output        io_isEfp_bGreater
);

  wire        NX;
  wire        OF;
  wire [11:0] _U_FS1_io_result;
  wire [11:0] _U_FS0_io_result;
  wire [25:0] _U_far_rshift_2_io_result;
  wire [25:0] _U_far_rshift_1_io_result;
  wire [4:0]  _U_Efp_bSubEfp_a_io_c;
  wire [4:0]  _U_Efp_aSubEfp_b_io_c;
  wire        efficient_fp_b_sign = io_fp_b[15] ^ io_is_sub;
  wire        EOP = io_fp_a[15] ^ efficient_fp_b_sign;
  reg         EOP_reg;
  reg         RNE_reg;
  reg         RTZ_reg;
  reg         RDN_reg;
  reg         RUP_reg;
  reg         RMM_reg;
  wire        _GEN = io_fp_a[10] | ~(|(io_fp_a[14:10]));
  wire        _GEN_0 = io_fp_b[10] | ~(|(io_fp_b[14:10]));
  wire        isEfp_bGreater = io_fp_b[14:10] > io_fp_a[14:10];
  wire [4:0]  absEaSubEb = isEfp_bGreater ? _U_Efp_bSubEfp_a_io_c : _U_Efp_aSubEfp_b_io_c;
  wire [10:0] significand_fp_a = {|(io_fp_a[14:10]), io_fp_a[9:0]};
  wire [10:0] significand_fp_b = {|(io_fp_b[14:10]), io_fp_b[9:0]};
  wire [10:0] greaterSignificand = isEfp_bGreater ? significand_fp_b : significand_fp_a;
  wire [11:0] _A_wire_FS1_T = {greaterSignificand, 1'h0};
  wire [11:0] _A_wire_FS1_T_1 = {1'h0, greaterSignificand};
  wire [11:0] A_wire = EOP ? _A_wire_FS1_T : _A_wire_FS1_T_1;
  wire [25:0] far_rshift_widen_result =
    isEfp_bGreater ? _U_far_rshift_2_io_result : _U_far_rshift_1_io_result;
  wire        absEaSubEb_is_greater = absEaSubEb > 5'hE;
  wire [11:0] B_wire = absEaSubEb_is_greater ? {12{EOP}} : far_rshift_widen_result[25:14];
  reg         B_guard_normal_reg;
  reg         B_round_normal_reg;
  reg         B_sticky_normal_reg_r;
  reg         B_sticky_normal_reg_r_1;
  reg         B_sticky_normal_reg_r_2;
  reg  [11:0] B_sticky_normal_reg_r_3;
  reg  [11:0] B_sticky_normal_reg_r_4;
  wire        B_rsticky_normal_reg =
    B_round_normal_reg
    | (B_sticky_normal_reg_r
         ? B_sticky_normal_reg_r_1
         : B_sticky_normal_reg_r_2
             ? (|B_sticky_normal_reg_r_3)
             : (|B_sticky_normal_reg_r_4));
  wire [1:0]  _lgs_normal_reg_T_5 = {B_guard_normal_reg, B_rsticky_normal_reg};
  wire [1:0]  _lgs_normal_reg_T_6 =
    EOP_reg ? 2'(~_lgs_normal_reg_T_5 + 2'h1) : _lgs_normal_reg_T_5;
  reg         far_sign_result_reg;
  wire        _far_case_overflow_round_up_T_13 = RDN_reg & far_sign_result_reg;
  wire        far_case_normal_round_up =
    EOP_reg & ~(_lgs_normal_reg_T_6[1]) & ~(_lgs_normal_reg_T_6[0]) | RNE_reg
    & _lgs_normal_reg_T_6[1] & (_U_FS0_io_result[0] | _lgs_normal_reg_T_6[0])
    | _far_case_overflow_round_up_T_13 & (|_lgs_normal_reg_T_6) | RUP_reg
    & ~far_sign_result_reg & (|_lgs_normal_reg_T_6) | RMM_reg & _lgs_normal_reg_T_6[1];
  reg         grs_overflow_r;
  reg         grs_overflow_r_1;
  wire [2:0]  grs_overflow =
    EOP_reg
      ? 3'({grs_overflow_r, 2'h0}
           - {grs_overflow_r_1, B_guard_normal_reg, B_rsticky_normal_reg})
      : {_U_FS0_io_result[0], B_guard_normal_reg, B_rsticky_normal_reg};
  wire        _lgs_overflow_T_4 = grs_overflow[1] | grs_overflow[0];
  wire        far_case_overflow_round_up =
    EOP_reg & ~(grs_overflow[2]) & ~_lgs_overflow_T_4 | RNE_reg & grs_overflow[2]
    & (_U_FS0_io_result[1] | _lgs_overflow_T_4) | _far_case_overflow_round_up_T_13
    & (grs_overflow[2] | _lgs_overflow_T_4) | RUP_reg & ~far_sign_result_reg
    & (grs_overflow[2] | _lgs_overflow_T_4) | RMM_reg & grs_overflow[2];
  reg         far_exponent_result_r;
  reg  [4:0]  far_exponent_result_r_1;
  reg  [4:0]  far_exponent_result_r_2;
  reg         OF_r;
  assign OF =
    OF_r
    & (_U_FS0_io_result[11] | _U_FS1_io_result[11] & _U_FS0_io_result[0]
       & far_case_normal_round_up);
  assign NX =
    (_U_FS0_io_result[11]
       ? (|{grs_overflow[2], _lgs_overflow_T_4})
       : (|_lgs_normal_reg_T_6)) | OF;
  wire [4:0]  E_greater = isEfp_bGreater ? io_fp_b[14:10] : io_fp_a[14:10];
  wire [4:0]  EA = EOP ? 5'(E_greater - 5'h1) : E_greater;
  wire [4:0]  _EA_add1_T = 5'(EA + 5'h1);
  always @(posedge clock) begin
    if (io_fire) begin
      EOP_reg <= EOP;
      RNE_reg <= io_round_mode == 3'h0;
      RTZ_reg <= io_round_mode == 3'h1;
      RDN_reg <= io_round_mode == 3'h2;
      RUP_reg <= io_round_mode == 3'h3;
      RMM_reg <= io_round_mode == 3'h4;
      B_guard_normal_reg <=
        ~absEaSubEb_is_greater
        & (EOP ? ~(far_rshift_widen_result[13]) : far_rshift_widen_result[13]);
      B_round_normal_reg <=
        ~absEaSubEb_is_greater
        & (EOP ? ~(far_rshift_widen_result[12]) : far_rshift_widen_result[12]);
      B_sticky_normal_reg_r <= absEaSubEb_is_greater;
      B_sticky_normal_reg_r_1 <= |(isEfp_bGreater ? significand_fp_a : significand_fp_b);
      B_sticky_normal_reg_r_2 <= EOP;
      B_sticky_normal_reg_r_3 <= ~(far_rshift_widen_result[11:0]);
      B_sticky_normal_reg_r_4 <= far_rshift_widen_result[11:0];
      far_sign_result_reg <= isEfp_bGreater ? efficient_fp_b_sign : io_fp_a[15];
      grs_overflow_r <= A_wire[0];
      grs_overflow_r_1 <= ~(B_wire[0]);
      far_exponent_result_r <= EA == 5'h0;
      far_exponent_result_r_1 <= _EA_add1_T;
      far_exponent_result_r_2 <= EA;
      OF_r <= &_EA_add1_T;
    end
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:1];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [1:0] i = 2'h0; i < 2'h2; i += 2'h1) begin
          _RANDOM[i[0]] = `RANDOM;
        end
        EOP_reg = _RANDOM[1'h0][0];
        RNE_reg = _RANDOM[1'h0][1];
        RTZ_reg = _RANDOM[1'h0][2];
        RDN_reg = _RANDOM[1'h0][3];
        RUP_reg = _RANDOM[1'h0][4];
        RMM_reg = _RANDOM[1'h0][5];
        B_guard_normal_reg = _RANDOM[1'h0][6];
        B_round_normal_reg = _RANDOM[1'h0][7];
        B_sticky_normal_reg_r = _RANDOM[1'h0][8];
        B_sticky_normal_reg_r_1 = _RANDOM[1'h0][9];
        B_sticky_normal_reg_r_2 = _RANDOM[1'h0][10];
        B_sticky_normal_reg_r_3 = _RANDOM[1'h0][22:11];
        B_sticky_normal_reg_r_4 = {_RANDOM[1'h0][31:23], _RANDOM[1'h1][2:0]};
        far_sign_result_reg = _RANDOM[1'h1][4];
        grs_overflow_r = _RANDOM[1'h1][5];
        grs_overflow_r_1 = _RANDOM[1'h1][6];
        far_exponent_result_r = _RANDOM[1'h1][7];
        far_exponent_result_r_1 = _RANDOM[1'h1][12:8];
        far_exponent_result_r_2 = _RANDOM[1'h1][17:13];
        OF_r = _RANDOM[1'h1][18];
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  Adder_18 U_Efp_aSubEfp_b (
    .io_a ({io_fp_a[14:11], _GEN}),
    .io_b ({io_fp_b[14:11], _GEN_0}),
    .io_c (_U_Efp_aSubEfp_b_io_c)
  );
  Adder_18 U_Efp_bSubEfp_a (
    .io_a ({io_fp_b[14:11], _GEN_0}),
    .io_b ({io_fp_a[14:11], _GEN}),
    .io_c (_U_Efp_bSubEfp_a_io_c)
  );
  FarShiftRightWithMuxInvFirst_18 U_far_rshift_1 (
    .io_src
      (EOP
         ? {~significand_fp_b, 15'h7FFF}
         : {1'h0, |(io_fp_b[14:10]), io_fp_b[9:0], 14'h0}),
    .io_shiftValue (_U_Efp_aSubEfp_b_io_c[3:0]),
    .io_result     (_U_far_rshift_1_io_result),
    .io_EOP        (EOP)
  );
  FarShiftRightWithMuxInvFirst_18 U_far_rshift_2 (
    .io_src
      (EOP
         ? {~significand_fp_a, 15'h7FFF}
         : {1'h0, |(io_fp_a[14:10]), io_fp_a[9:0], 14'h0}),
    .io_shiftValue (_U_Efp_bSubEfp_a_io_c[3:0]),
    .io_result     (_U_far_rshift_2_io_result),
    .io_EOP        (EOP)
  );
  FarPathAdderF16Pipeline U_FS0 (
    .clock     (clock),
    .io_fire   (io_fire),
    .io_A      (A_wire),
    .io_B      (B_wire),
    .io_result (_U_FS0_io_result)
  );
  FarPathAdderF16Pipeline U_FS1 (
    .clock     (clock),
    .io_fire   (io_fire),
    .io_A      (12'((EOP ? _A_wire_FS1_T : _A_wire_FS1_T_1) + 12'h2)),
    .io_B      (B_wire),
    .io_result (_U_FS1_io_result)
  );
  assign io_fp_c =
    {far_sign_result_reg,
     OF
       ? (RTZ_reg | RDN_reg & ~far_sign_result_reg | RUP_reg & far_sign_result_reg
            ? 15'h7BFF
            : 15'h7C00)
       : {_U_FS0_io_result[11] | _U_FS1_io_result[11] & _U_FS0_io_result[0]
          & far_case_normal_round_up | far_exponent_result_r & _U_FS0_io_result[10]
            ? far_exponent_result_r_1
            : far_exponent_result_r_2,
          (~(_U_FS0_io_result[11])
           & (~(_U_FS0_io_result[0]) & far_case_normal_round_up
              | ~far_case_normal_round_up)
             ? {_U_FS0_io_result[9:1], _U_FS0_io_result[0] ^ far_case_normal_round_up}
             : 10'h0)
            | (~(_U_FS0_io_result[11]) & _U_FS0_io_result[0] & far_case_normal_round_up
                 ? {_U_FS1_io_result[9:1], 1'h0}
                 : 10'h0)
            | (_U_FS0_io_result[11]
               & (~(_U_FS0_io_result[1]) & far_case_overflow_round_up
                  | ~far_case_overflow_round_up)
                 ? {_U_FS0_io_result[10:2],
                    _U_FS0_io_result[1] ^ far_case_overflow_round_up}
                 : 10'h0)
            | (_U_FS0_io_result[11] & _U_FS0_io_result[1] & far_case_overflow_round_up
                 ? _U_FS1_io_result[10:1]
                 : 10'h0)}};
  assign io_fflags = {2'h0, OF, 1'h0, NX};
  assign io_absEaSubEb = absEaSubEb;
  assign io_isEfp_bGreater = isEfp_bGreater;
endmodule

