// Generated by CIRCT firtool-1.62.1
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

module FloatAdderF32WidenF16MixedPipeline(
  input         clock,
  input         io_fire,
  input  [31:0] io_fp_a,
  input  [31:0] io_fp_b,
  input  [31:0] io_widen_a,
  input  [31:0] io_widen_b,
  output [31:0] io_fp_c,
  input         io_is_sub,
  input         io_mask,
  input  [2:0]  io_round_mode,
  output [4:0]  io_fflags,
  input  [1:0]  io_fp_format,
  input         io_opb_widening,
  input         io_res_widening,
  input  [4:0]  io_op_code,
  input  [1:0]  io_maskForReduction,
  input         io_is_vfwredosum
);

  wire [31:0] _U_close_path_io_fp_c;
  wire [4:0]  _U_close_path_io_fflags;
  wire [24:0] _U_close_path_io_CS1;
  wire [31:0] _U_far_path_io_fp_c;
  wire [4:0]  _U_far_path_io_fflags;
  wire [7:0]  _U_far_path_io_absEaSubEb;
  wire        _U_far_path_io_isEfp_bGreater;
  wire [31:0] fp_a_to32 =
    io_res_widening & ~io_opb_widening
      ? io_widen_a
      : io_fp_format[0] ? io_fp_a : {io_fp_a[15], 3'h0, io_fp_a[14:0], 13'h0};
  wire [31:0] fp_b_to32 =
    io_res_widening & ~io_is_vfwredosum
      ? io_widen_b
      : io_fp_format[0] ? io_fp_b : {io_fp_b[15], 3'h0, io_fp_b[14:0], 13'h0};
  reg         is_far_path_reg;
  reg         r;
  reg         r_1;
  reg         res_is_f32_reg;
  reg         out_infinite_sign_reg;
  wire [31:0] out_fp32_reg =
    is_far_path_reg ? _U_far_path_io_fp_c : _U_close_path_io_fp_c;
  reg         r_2;
  reg         r_3;
  reg         r_4;
  reg         float_adder_result_r;
  reg         r_5;
  reg  [31:0] float_adder_result_r_1;
  reg         r_6;
  reg  [31:0] float_adder_result_r_2;
  reg         io_fp_c_r;
  reg  [31:0] io_fp_c_r_1;
  reg         io_fflags_r;
  reg  [4:0]  io_fflags_r_1;
  wire        EOP = fp_a_to32[31] ^ io_is_sub ^ fp_b_to32[31];
  wire        fp_a_is_f16 = ~(io_fp_format[0]) | io_res_widening & ~io_opb_widening;
  wire        fp_b_is_f16 = ~(io_fp_format[0]) | io_res_widening & ~io_is_vfwredosum;
  wire        Efp_a_is_zero =
    fp_a_to32[30:23] == 8'h0 | fp_a_is_f16 & fp_a_to32[30:23] == 8'h66;
  wire        Efp_b_is_zero =
    fp_b_to32[30:23] == 8'h0 | fp_b_is_f16 & fp_b_to32[30:23] == 8'h66;
  wire        Efp_a_is_all_one =
    fp_a_is_f16
      ? (io_res_widening ? fp_a_to32[30:23] == 8'h8F : (&(io_fp_a[14:10])))
      : (&(io_fp_a[30:23]));
  wire        Efp_b_is_all_one =
    fp_b_is_f16
      ? (io_res_widening ? fp_b_to32[30:23] == 8'h8F : (&(io_fp_b[14:10])))
      : (&(io_fp_b[30:23]));
  wire        _fp_a_is_NAN_T = Efp_a_is_all_one & (|(fp_a_to32[22:0]));
  wire        fp_a_is_SNAN = Efp_a_is_all_one & (|(fp_a_to32[22:0])) & ~(fp_a_to32[22]);
  wire        _fp_b_is_NAN_T = Efp_b_is_all_one & (|(fp_b_to32[22:0]));
  wire        fp_b_is_SNAN = Efp_b_is_all_one & (|(fp_b_to32[22:0])) & ~(fp_b_to32[22]);
  wire        fp_a_is_infinite = Efp_a_is_all_one & ~(|(fp_a_to32[22:0]));
  wire        fp_b_is_infinite = Efp_b_is_all_one & ~(|(fp_b_to32[22:0]));
  wire        fp_a_is_zero = Efp_a_is_zero & ~(|(fp_a_to32[22:0]));
  wire        fp_b_is_zero = Efp_b_is_zero & ~(|(fp_b_to32[22:0]));
  wire        _fflags_NV_stage0_T_4 = fp_a_is_SNAN | fp_b_is_SNAN;
  wire        _GEN = EOP & fp_a_is_infinite & fp_b_is_infinite;
  wire        _fflags_NV_stage0_T_10 = _fp_a_is_NAN_T | _fp_b_is_NAN_T;
  wire        _GEN_0 = io_res_widening & fp_a_is_zero;
  wire        is_min = io_op_code == 5'h2;
  wire        is_max = io_op_code == 5'h3;
  wire        is_feq = io_op_code == 5'h9;
  wire        is_fne = io_op_code == 5'hA;
  wire        is_flt = io_op_code == 5'hB;
  wire        is_fle = io_op_code == 5'hC;
  wire        is_fgt = io_op_code == 5'hD;
  wire        is_fge = io_op_code == 5'hE;
  wire        is_fsum_ure = io_op_code == 5'h1A;
  wire        is_fmin_re = io_op_code == 5'h14;
  wire        is_fmax_re = io_op_code == 5'h15;
  wire        is_fsum_ore = io_op_code == 5'h16;
  wire        fp_b_exponent_is_equal = fp_a_to32[30:23] == fp_b_to32[30:23];
  wire        fp_b_significand_is_greater =
    ~(_U_close_path_io_CS1[24]) & fp_a_to32[22:0] != fp_b_to32[22:0];
  wire        fp_b_significand_is_equal = fp_a_to32[22:0] == fp_b_to32[22:0];
  wire        _fp_b_is_equal_T_2 = fp_b_is_zero & fp_a_is_zero;
  wire        fp_b_is_greater =
    ~(fp_b_to32[31])
    & (fp_a_to32[31] & ~_fp_b_is_equal_T_2 | _U_far_path_io_isEfp_bGreater
       | fp_b_exponent_is_equal & fp_b_significand_is_greater) | fp_b_to32[31]
    & fp_a_to32[31]
    & (~_U_far_path_io_isEfp_bGreater & ~fp_b_exponent_is_equal | fp_b_exponent_is_equal
       & ~fp_b_significand_is_greater & ~fp_b_significand_is_equal);
  wire        fp_b_is_equal =
    fp_a_to32[31] == fp_b_to32[31] & fp_b_exponent_is_equal & fp_b_significand_is_equal
    | _fp_b_is_equal_T_2;
  wire        fp_b_is_less = ~fp_b_is_greater & ~fp_b_is_equal;
  wire [31:0] out_NAN = io_fp_format[0] ? 32'h7FC00000 : 32'h7E00;
  wire        zero_sign = io_round_mode != 3'h2;
  wire [31:0] fp_a_16_or_32 = io_fp_format[0] ? io_fp_a : {16'h0, io_fp_a[15:0]};
  wire [31:0] fp_b_16_or_32 = io_fp_format[0] ? io_fp_b : {16'h0, io_fp_b[15:0]};
  wire        _result_max_T_7 = _fp_a_is_NAN_T & _fp_b_is_NAN_T;
  wire        _GEN_1 = _fp_a_is_NAN_T | _fp_b_is_NAN_T;
  wire [31:0] _result_min_T_19 =
    (_GEN_1
       ? 32'h0
       : fp_b_is_less | fp_b_to32[31] & fp_b_is_zero & fp_a_is_zero
           ? fp_b_16_or_32
           : fp_a_16_or_32) | (~_fp_a_is_NAN_T & _fp_b_is_NAN_T ? fp_a_16_or_32 : 32'h0)
    | (_fp_a_is_NAN_T & ~_fp_b_is_NAN_T ? fp_b_16_or_32 : 32'h0)
    | (_result_max_T_7 ? out_NAN : 32'h0);
  wire [31:0] _result_max_T_21 =
    (_GEN_1
       ? 32'h0
       : fp_b_is_greater | ~(fp_b_to32[31]) & fp_b_is_zero & fp_a_is_zero
           ? fp_b_16_or_32
           : fp_a_16_or_32) | (~_fp_a_is_NAN_T & _fp_b_is_NAN_T ? fp_a_16_or_32 : 32'h0)
    | (_fp_a_is_NAN_T & ~_fp_b_is_NAN_T ? fp_b_16_or_32 : 32'h0)
    | (_result_max_T_7 ? out_NAN : 32'h0);
  wire        _result_feq_T_1 = ~_fflags_NV_stage0_T_10 & fp_b_is_equal;
  wire        _result_fclass_T_7 = fp_a_to32[31] & Efp_a_is_zero;
  wire        is_fsum_ure_notmasked = is_fsum_ure & (&io_maskForReduction);
  wire        is_fsum_ore_notmasked = is_fsum_ore & io_maskForReduction[0];
  wire        _result_fmin_re_T = io_maskForReduction == 2'h0;
  wire [31:0] re_masked_one_out = io_maskForReduction[0] ? io_fp_a : io_fp_b;
  wire        _io_fflags_T = io_op_code == 5'h0 | io_op_code == 5'h1;
  always @(posedge clock) begin
    if (io_fire) begin
      is_far_path_reg <=
        ~EOP | EOP & (|(_U_far_path_io_absEaSubEb[7:1]))
        | _U_far_path_io_absEaSubEb == 8'h1 & (Efp_a_is_zero ^ Efp_b_is_zero);
      r <= _fflags_NV_stage0_T_4 | _GEN;
      r_1 <=
        _fp_a_is_NAN_T | _fp_b_is_NAN_T | fp_a_is_infinite | fp_b_is_infinite
        | (fp_b_is_zero | fp_a_is_zero) & io_res_widening;
      res_is_f32_reg <= io_fp_format[0];
      out_infinite_sign_reg <=
        fp_a_is_infinite ? fp_a_to32[31] : io_is_sub ^ fp_b_to32[31];
      r_2 <= _fflags_NV_stage0_T_10 | _GEN;
      r_3 <= fp_a_is_infinite | fp_b_is_infinite;
      r_4 <= _GEN_0 & fp_b_is_zero;
      float_adder_result_r <= io_round_mode == 3'h2 & EOP | fp_a_to32[31] & ~EOP;
      r_5 <= _GEN_0;
      float_adder_result_r_1 <= {io_is_sub ^ fp_b_to32[31], fp_b_to32[30:0]};
      r_6 <= io_res_widening & fp_b_is_zero;
      float_adder_result_r_2 <= fp_a_to32;
      io_fp_c_r <= _io_fflags_T | is_fsum_ure_notmasked | is_fsum_ore_notmasked;
      io_fp_c_r_1 <=
        (is_min ? _result_min_T_19 : 32'h0) | (is_max ? _result_max_T_21 : 32'h0)
        | (is_feq ? {31'h0, _result_feq_T_1} : 32'h0)
        | (is_fne ? {31'h0, ~_result_feq_T_1} : 32'h0)
        | (is_flt ? {31'h0, ~_fflags_NV_stage0_T_10 & fp_b_is_greater} : 32'h0)
        | (is_fle
             ? {31'h0, ~_fflags_NV_stage0_T_10 & (fp_b_is_greater | fp_b_is_equal)}
             : 32'h0) | (is_fgt ? {31'h0, ~_fflags_NV_stage0_T_10 & fp_b_is_less} : 32'h0)
        | (is_fge
             ? {31'h0, ~_fflags_NV_stage0_T_10 & (fp_b_is_less | fp_b_is_equal)}
             : 32'h0)
        | (io_op_code == 5'h6
             ? (io_fp_format[0]
                  ? {io_fp_b[31], io_fp_a[30:0]}
                  : {16'h0, io_fp_b[15], io_fp_a[14:0]})
             : 32'h0)
        | (io_op_code == 5'h7
             ? (io_fp_format[0]
                  ? {~(io_fp_b[31]), io_fp_a[30:0]}
                  : {16'h0, ~(io_fp_b[15]), io_fp_a[14:0]})
             : 32'h0)
        | (io_op_code == 5'h8
             ? (io_fp_format[0]
                  ? {io_fp_b[31] ^ io_fp_a[31], io_fp_a[30:0]}
                  : {16'h0, io_fp_b[15] ^ io_fp_a[15], io_fp_a[14:0]})
             : 32'h0)
        | (io_op_code == 5'hF
             ? {22'h0,
                _fp_a_is_NAN_T & ~fp_a_is_SNAN,
                fp_a_is_SNAN,
                ~(fp_a_to32[31]) & fp_a_is_infinite,
                ~(fp_a_to32[31]) & ~Efp_a_is_zero & ~Efp_a_is_all_one,
                ~(fp_a_to32[31]) & Efp_a_is_zero & (|(fp_a_to32[22:0])),
                ~(fp_a_to32[31]) & Efp_a_is_zero & ~(|(fp_a_to32[22:0])),
                _result_fclass_T_7 & ~(|(fp_a_to32[22:0])),
                _result_fclass_T_7 & (|(fp_a_to32[22:0])),
                fp_a_to32[31] & ~Efp_a_is_zero & ~Efp_a_is_all_one,
                fp_a_to32[31] & fp_a_is_infinite}
             : 32'h0)
        | (io_op_code == 5'h4
             ? (io_fp_format[0]
                  ? (io_mask ? io_fp_b : io_fp_a)
                  : {16'h0, io_mask ? io_fp_b[15:0] : io_fp_a[15:0]})
             : 32'h0)
        | (io_op_code == 5'h5 | io_op_code == 5'h11 | io_op_code == 5'h12
             ? (io_fp_format[0] ? io_fp_b : {16'h0, io_fp_b[15:0]})
             : 32'h0)
        | (is_fsum_ure & ~(&io_maskForReduction)
             ? (_result_fmin_re_T
                  ? (io_fp_format[0] ? {zero_sign, 31'h0} : {16'h0, zero_sign, 15'h0})
                  : io_maskForReduction[0] ? io_fp_a : io_fp_b)
             : 32'h0)
        | (is_fmax_re
             ? (_result_fmin_re_T
                  ? out_NAN
                  : (&io_maskForReduction) ? _result_max_T_21 : re_masked_one_out)
             : 32'h0)
        | (is_fmin_re
             ? (_result_fmin_re_T
                  ? out_NAN
                  : (&io_maskForReduction) ? _result_min_T_19 : re_masked_one_out)
             : 32'h0)
        | (is_fsum_ore & ~(io_maskForReduction[0]) & ~(io_maskForReduction[0])
             ? io_fp_b
             : 32'h0);
      io_fflags_r <= _io_fflags_T | is_fsum_ure_notmasked | is_fsum_ore_notmasked;
      io_fflags_r_1 <=
        {(is_min | is_max) & _fflags_NV_stage0_T_4 | (is_feq | is_fne)
           & _fflags_NV_stage0_T_4 | (is_flt | is_fle | is_fgt | is_fge)
           & _fflags_NV_stage0_T_10 | (is_fmax_re | is_fmin_re)
           & (io_maskForReduction[0] & fp_a_is_SNAN | io_maskForReduction[1]
              & fp_b_is_SNAN),
         4'h0};
    end
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:3];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [2:0] i = 3'h0; i < 3'h4; i += 3'h1) begin
          _RANDOM[i[1:0]] = `RANDOM;
        end
        is_far_path_reg = _RANDOM[2'h0][0];
        r = _RANDOM[2'h0][1];
        r_1 = _RANDOM[2'h0][2];
        res_is_f32_reg = _RANDOM[2'h0][3];
        out_infinite_sign_reg = _RANDOM[2'h0][4];
        r_2 = _RANDOM[2'h0][5];
        r_3 = _RANDOM[2'h0][6];
        r_4 = _RANDOM[2'h0][7];
        float_adder_result_r = _RANDOM[2'h0][8];
        r_5 = _RANDOM[2'h0][9];
        float_adder_result_r_1 = {_RANDOM[2'h0][31:10], _RANDOM[2'h1][9:0]};
        r_6 = _RANDOM[2'h1][10];
        float_adder_result_r_2 = {_RANDOM[2'h1][31:11], _RANDOM[2'h2][10:0]};
        io_fp_c_r = _RANDOM[2'h2][11];
        io_fp_c_r_1 = {_RANDOM[2'h2][31:12], _RANDOM[2'h3][11:0]};
        io_fflags_r = _RANDOM[2'h3][12];
        io_fflags_r_1 = _RANDOM[2'h3][17:13];
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  FarPathF32WidenF16MixedPipeline U_far_path (
    .clock             (clock),
    .io_fire           (io_fire),
    .io_fp_a           (fp_a_to32),
    .io_fp_b           (fp_b_to32),
    .io_fp_c           (_U_far_path_io_fp_c),
    .io_is_sub         (io_is_sub),
    .io_round_mode     (io_round_mode),
    .io_fflags         (_U_far_path_io_fflags),
    .io_absEaSubEb     (_U_far_path_io_absEaSubEb),
    .io_res_is_f32     (io_fp_format[0]),
    .io_isEfp_bGreater (_U_far_path_io_isEfp_bGreater)
  );
  ClosePathF32WidenF16MixedPipeline U_close_path (
    .clock         (clock),
    .io_fire       (io_fire),
    .io_fp_a       (fp_a_to32),
    .io_fp_b       (fp_b_to32),
    .io_fp_c       (_U_close_path_io_fp_c),
    .io_round_mode (io_round_mode),
    .io_fflags     (_U_close_path_io_fflags),
    .io_res_is_f32 (io_fp_format[0]),
    .io_CS1        (_U_close_path_io_CS1)
  );
  assign io_fp_c =
    io_fp_c_r
      ? (r_2
           ? (res_is_f32_reg ? 32'h7FC00000 : 32'h7E00)
           : r_3
               ? (res_is_f32_reg
                    ? {out_infinite_sign_reg, 31'h7F800000}
                    : {16'h0, out_infinite_sign_reg, 15'h7C00})
               : r_4
                   ? {float_adder_result_r, 31'h0}
                   : r_5
                       ? float_adder_result_r_1
                       : r_6
                           ? float_adder_result_r_2
                           : res_is_f32_reg
                               ? out_fp32_reg
                               : {16'h0, out_fp32_reg[31], out_fp32_reg[27:13]})
      : io_fp_c_r_1;
  assign io_fflags =
    io_fflags_r
      ? (r
           ? 5'h10
           : r_1
               ? 5'h0
               : is_far_path_reg ? _U_far_path_io_fflags : _U_close_path_io_fflags)
      : io_fflags_r_1;
endmodule

