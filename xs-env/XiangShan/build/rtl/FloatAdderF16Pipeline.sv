// Generated by CIRCT firtool-1.62.1
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

module FloatAdderF16Pipeline(
  input         clock,
  input         io_fire,
  input  [15:0] io_fp_a,
  input  [15:0] io_fp_b,
  output [15:0] io_fp_c,
  input         io_is_sub,
  input         io_mask,
  input  [2:0]  io_round_mode,
  output [4:0]  io_fflags,
  input  [4:0]  io_op_code,
  input  [1:0]  io_maskForReduction
);

  wire [15:0] _U_close_path_io_fp_c;
  wire [4:0]  _U_close_path_io_fflags;
  wire [11:0] _U_close_path_io_CS1;
  wire [15:0] _U_far_path_io_fp_c;
  wire [4:0]  _U_far_path_io_fflags;
  wire [4:0]  _U_far_path_io_absEaSubEb;
  wire        _U_far_path_io_isEfp_bGreater;
  reg         r;
  reg         r_1;
  reg         float_adder_fflags_r;
  reg         r_2;
  reg         r_3;
  reg         float_adder_result_r;
  reg         float_adder_result_r_1;
  reg         io_fp_c_r;
  reg  [15:0] io_fp_c_r_1;
  reg         io_fflags_r;
  reg  [4:0]  io_fflags_r_1;
  wire        EOP = io_fp_a[15] ^ io_is_sub ^ io_fp_b[15];
  wire        is_far_path =
    ~EOP | (|(_U_far_path_io_absEaSubEb[4:1])) | _U_far_path_io_absEaSubEb == 5'h1
    & ((|(io_fp_a[14:10])) ^ (|(io_fp_b[14:10])));
  wire        _fp_a_is_NAN_T = (&(io_fp_a[14:10])) & (|(io_fp_a[9:0]));
  wire        fp_a_is_SNAN = (&(io_fp_a[14:10])) & (|(io_fp_a[9:0])) & ~(io_fp_a[9]);
  wire        _fp_b_is_NAN_T = (&(io_fp_b[14:10])) & (|(io_fp_b[9:0]));
  wire        fp_b_is_SNAN = (&(io_fp_b[14:10])) & (|(io_fp_b[9:0])) & ~(io_fp_b[9]);
  wire        fp_a_is_infinite = (&(io_fp_a[14:10])) & ~(|(io_fp_a[9:0]));
  wire        fp_b_is_infinite = (&(io_fp_b[14:10])) & ~(|(io_fp_b[9:0]));
  wire        _fflags_NV_stage0_T_4 = fp_a_is_SNAN | fp_b_is_SNAN;
  wire        _GEN = EOP & fp_a_is_infinite & fp_b_is_infinite;
  wire        _fflags_NV_stage0_T_10 = _fp_a_is_NAN_T | _fp_b_is_NAN_T;
  wire        fp_a_is_zero = ~(|(io_fp_a[14:10])) & ~(|(io_fp_a[9:0]));
  wire        fp_b_is_zero = ~(|(io_fp_b[14:10])) & ~(|(io_fp_b[9:0]));
  wire        is_min = io_op_code == 5'h2;
  wire        is_max = io_op_code == 5'h3;
  wire        is_feq = io_op_code == 5'h9;
  wire        is_fne = io_op_code == 5'hA;
  wire        is_flt = io_op_code == 5'hB;
  wire        is_fle = io_op_code == 5'hC;
  wire        is_fgt = io_op_code == 5'hD;
  wire        is_fge = io_op_code == 5'hE;
  wire        is_fsum_ure = io_op_code == 5'h1A;
  wire        is_fmin_re = io_op_code == 5'h14;
  wire        is_fmax_re = io_op_code == 5'h15;
  wire        is_fsum_ore = io_op_code == 5'h16;
  wire        fp_b_exponent_is_equal = io_fp_a[14:10] == io_fp_b[14:10];
  wire        fp_b_significand_is_greater =
    ~(_U_close_path_io_CS1[11]) & io_fp_a[9:0] != io_fp_b[9:0];
  wire        fp_b_significand_is_equal = io_fp_a[9:0] == io_fp_b[9:0];
  wire        _fp_b_is_equal_T_2 = fp_b_is_zero & fp_a_is_zero;
  wire        fp_b_is_greater =
    ~(io_fp_b[15])
    & (io_fp_a[15] & ~_fp_b_is_equal_T_2 | _U_far_path_io_isEfp_bGreater
       | fp_b_exponent_is_equal & fp_b_significand_is_greater) | io_fp_b[15] & io_fp_a[15]
    & (~_U_far_path_io_isEfp_bGreater & ~fp_b_exponent_is_equal | fp_b_exponent_is_equal
       & ~fp_b_significand_is_greater & ~fp_b_significand_is_equal);
  wire        fp_b_is_equal =
    io_fp_a[15] == io_fp_b[15] & fp_b_exponent_is_equal & fp_b_significand_is_equal
    | _fp_b_is_equal_T_2;
  wire        fp_b_is_less = ~fp_b_is_greater & ~fp_b_is_equal;
  wire        _result_max_T_7 = _fp_a_is_NAN_T & _fp_b_is_NAN_T;
  wire        _GEN_0 = _fp_a_is_NAN_T | _fp_b_is_NAN_T;
  wire [15:0] _result_min_T_19 =
    (_GEN_0
       ? 16'h0
       : fp_b_is_less | io_fp_b[15] & fp_b_is_zero & fp_a_is_zero ? io_fp_b : io_fp_a)
    | (~_fp_a_is_NAN_T & _fp_b_is_NAN_T ? io_fp_a : 16'h0)
    | (_fp_a_is_NAN_T & ~_fp_b_is_NAN_T ? io_fp_b : 16'h0)
    | (_result_max_T_7 ? 16'h7E00 : 16'h0);
  wire [15:0] _result_max_T_21 =
    (_GEN_0
       ? 16'h0
       : fp_b_is_greater | ~(io_fp_b[15]) & fp_b_is_zero & fp_a_is_zero
           ? io_fp_b
           : io_fp_a) | (~_fp_a_is_NAN_T & _fp_b_is_NAN_T ? io_fp_a : 16'h0)
    | (_fp_a_is_NAN_T & ~_fp_b_is_NAN_T ? io_fp_b : 16'h0)
    | (_result_max_T_7 ? 16'h7E00 : 16'h0);
  wire        _result_feq_T_1 = ~_fflags_NV_stage0_T_10 & fp_b_is_equal;
  wire        _result_fclass_T_7 = io_fp_a[15] & ~(|(io_fp_a[14:10]));
  wire        is_fsum_ure_notmasked = is_fsum_ure & (&io_maskForReduction);
  wire        is_fsum_ore_notmasked = is_fsum_ore & io_maskForReduction[0];
  wire        _result_fmin_re_T = io_maskForReduction == 2'h0;
  wire [15:0] re_masked_one_out = io_maskForReduction[0] ? io_fp_a : io_fp_b;
  wire        _io_fflags_T = io_op_code == 5'h0 | io_op_code == 5'h1;
  always @(posedge clock) begin
    if (io_fire) begin
      r <= _fflags_NV_stage0_T_4 | _GEN;
      r_1 <= _fp_a_is_NAN_T | _fp_b_is_NAN_T | fp_a_is_infinite | fp_b_is_infinite;
      float_adder_fflags_r <= is_far_path;
      r_2 <= _fflags_NV_stage0_T_10 | _GEN;
      r_3 <= fp_a_is_infinite | fp_b_is_infinite;
      float_adder_result_r <= fp_a_is_infinite ? io_fp_a[15] : io_is_sub ^ io_fp_b[15];
      float_adder_result_r_1 <= is_far_path;
      io_fp_c_r <= _io_fflags_T | is_fsum_ure_notmasked | is_fsum_ore_notmasked;
      io_fp_c_r_1 <=
        (is_min ? _result_min_T_19 : 16'h0) | (is_max ? _result_max_T_21 : 16'h0)
        | (is_feq ? {15'h0, _result_feq_T_1} : 16'h0)
        | (is_fne ? {15'h0, ~_result_feq_T_1} : 16'h0)
        | (is_flt ? {15'h0, ~_fflags_NV_stage0_T_10 & fp_b_is_greater} : 16'h0)
        | (is_fle
             ? {15'h0, ~_fflags_NV_stage0_T_10 & (fp_b_is_greater | fp_b_is_equal)}
             : 16'h0) | (is_fgt ? {15'h0, ~_fflags_NV_stage0_T_10 & fp_b_is_less} : 16'h0)
        | (is_fge
             ? {15'h0, ~_fflags_NV_stage0_T_10 & (fp_b_is_less | fp_b_is_equal)}
             : 16'h0) | (io_op_code == 5'h6 ? {io_fp_b[15], io_fp_a[14:0]} : 16'h0)
        | (io_op_code == 5'h7 ? {~(io_fp_b[15]), io_fp_a[14:0]} : 16'h0)
        | (io_op_code == 5'h8 ? {io_fp_b[15] ^ io_fp_a[15], io_fp_a[14:0]} : 16'h0)
        | (io_op_code == 5'hF
             ? {6'h0,
                _fp_a_is_NAN_T & ~fp_a_is_SNAN,
                fp_a_is_SNAN,
                ~(io_fp_a[15]) & fp_a_is_infinite,
                ~(io_fp_a[15]) & (|(io_fp_a[14:10])) & ~(&(io_fp_a[14:10])),
                ~(io_fp_a[15]) & ~(|(io_fp_a[14:10])) & (|(io_fp_a[9:0])),
                ~(io_fp_a[15]) & ~(|(io_fp_a[14:10])) & ~(|(io_fp_a[9:0])),
                _result_fclass_T_7 & ~(|(io_fp_a[9:0])),
                _result_fclass_T_7 & (|(io_fp_a[9:0])),
                io_fp_a[15] & (|(io_fp_a[14:10])) & ~(&(io_fp_a[14:10])),
                io_fp_a[15] & fp_a_is_infinite}
             : 16'h0) | (io_op_code == 5'h4 ? (io_mask ? io_fp_b : io_fp_a) : 16'h0)
        | (io_op_code == 5'h5 | io_op_code == 5'h11 | io_op_code == 5'h12
             ? io_fp_b
             : 16'h0)
        | (is_fsum_ure & ~(&io_maskForReduction)
             ? (_result_fmin_re_T
                  ? {io_round_mode != 3'h2, 15'h0}
                  : io_maskForReduction[0] ? io_fp_a : io_fp_b)
             : 16'h0)
        | (is_fmax_re
             ? (_result_fmin_re_T
                  ? 16'h7E00
                  : (&io_maskForReduction) ? _result_max_T_21 : re_masked_one_out)
             : 16'h0)
        | (is_fmin_re
             ? (_result_fmin_re_T
                  ? 16'h7E00
                  : (&io_maskForReduction) ? _result_min_T_19 : re_masked_one_out)
             : 16'h0)
        | (is_fsum_ore & ~(io_maskForReduction[0]) & ~(io_maskForReduction[0])
             ? io_fp_b
             : 16'h0);
      io_fflags_r <= _io_fflags_T | is_fsum_ure_notmasked | is_fsum_ore_notmasked;
      io_fflags_r_1 <=
        {(is_min | is_max) & _fflags_NV_stage0_T_4 | (is_feq | is_fne)
           & _fflags_NV_stage0_T_4 | (is_flt | is_fle | is_fgt | is_fge)
           & _fflags_NV_stage0_T_10 | (is_fmax_re | is_fmin_re)
           & (io_maskForReduction[0] & fp_a_is_SNAN | io_maskForReduction[1]
              & fp_b_is_SNAN),
         4'h0};
    end
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        r = _RANDOM[/*Zero width*/ 1'b0][0];
        r_1 = _RANDOM[/*Zero width*/ 1'b0][1];
        float_adder_fflags_r = _RANDOM[/*Zero width*/ 1'b0][2];
        r_2 = _RANDOM[/*Zero width*/ 1'b0][3];
        r_3 = _RANDOM[/*Zero width*/ 1'b0][4];
        float_adder_result_r = _RANDOM[/*Zero width*/ 1'b0][5];
        float_adder_result_r_1 = _RANDOM[/*Zero width*/ 1'b0][6];
        io_fp_c_r = _RANDOM[/*Zero width*/ 1'b0][7];
        io_fp_c_r_1 = _RANDOM[/*Zero width*/ 1'b0][23:8];
        io_fflags_r = _RANDOM[/*Zero width*/ 1'b0][24];
        io_fflags_r_1 = _RANDOM[/*Zero width*/ 1'b0][29:25];
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  FarPathF16Pipeline U_far_path (
    .clock             (clock),
    .io_fire           (io_fire),
    .io_fp_a           (io_fp_a),
    .io_fp_b           (io_fp_b),
    .io_fp_c           (_U_far_path_io_fp_c),
    .io_is_sub         (io_is_sub),
    .io_round_mode     (io_round_mode),
    .io_fflags         (_U_far_path_io_fflags),
    .io_absEaSubEb     (_U_far_path_io_absEaSubEb),
    .io_isEfp_bGreater (_U_far_path_io_isEfp_bGreater)
  );
  ClosePathF16Pipeline U_close_path (
    .clock         (clock),
    .io_fire       (io_fire),
    .io_fp_a       (io_fp_a),
    .io_fp_b       (io_fp_b),
    .io_fp_c       (_U_close_path_io_fp_c),
    .io_round_mode (io_round_mode),
    .io_fflags     (_U_close_path_io_fflags),
    .io_CS1        (_U_close_path_io_CS1)
  );
  assign io_fp_c =
    io_fp_c_r
      ? (r_2
           ? 16'h7E00
           : r_3
               ? {float_adder_result_r, 15'h7C00}
               : float_adder_result_r_1 ? _U_far_path_io_fp_c : _U_close_path_io_fp_c)
      : io_fp_c_r_1;
  assign io_fflags =
    io_fflags_r
      ? (r
           ? 5'h10
           : r_1
               ? 5'h0
               : float_adder_fflags_r ? _U_far_path_io_fflags : _U_close_path_io_fflags)
      : io_fflags_r_1;
endmodule

