// Generated by CIRCT firtool-1.62.1
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

module DatamoduleResultBuffer(
  input          clock,
  input          reset,
  output         io_enq_0_ready,
  input          io_enq_0_valid,
  input  [47:0]  io_enq_0_bits_addr,
  input  [49:0]  io_enq_0_bits_vaddr,
  input  [127:0] io_enq_0_bits_data,
  input  [15:0]  io_enq_0_bits_mask,
  input          io_enq_0_bits_wline,
  input  [5:0]   io_enq_0_bits_sqPtr_value,
  input          io_enq_0_bits_vecValid,
  output         io_enq_1_ready,
  input          io_enq_1_valid,
  input  [47:0]  io_enq_1_bits_addr,
  input  [49:0]  io_enq_1_bits_vaddr,
  input  [127:0] io_enq_1_bits_data,
  input  [15:0]  io_enq_1_bits_mask,
  input          io_enq_1_bits_wline,
  input  [5:0]   io_enq_1_bits_sqPtr_value,
  input          io_enq_1_bits_vecValid,
  input          io_enq_1_bits_sqNeedDeq,
  input          io_deq_0_ready,
  output         io_deq_0_valid,
  output [47:0]  io_deq_0_bits_addr,
  output [49:0]  io_deq_0_bits_vaddr,
  output [127:0] io_deq_0_bits_data,
  output [15:0]  io_deq_0_bits_mask,
  output         io_deq_0_bits_wline,
  output [5:0]   io_deq_0_bits_sqPtr_value,
  output         io_deq_0_bits_vecValid,
  output         io_deq_0_bits_sqNeedDeq,
  input          io_deq_1_ready,
  output         io_deq_1_valid,
  output [47:0]  io_deq_1_bits_addr,
  output [49:0]  io_deq_1_bits_vaddr,
  output [127:0] io_deq_1_bits_data,
  output [15:0]  io_deq_1_bits_mask,
  output         io_deq_1_bits_wline,
  output [5:0]   io_deq_1_bits_sqPtr_value,
  output         io_deq_1_bits_vecValid,
  output         io_deq_1_bits_sqNeedDeq
);

  reg  [47:0]  data_0_addr;
  reg  [49:0]  data_0_vaddr;
  reg  [127:0] data_0_data;
  reg  [15:0]  data_0_mask;
  reg          data_0_wline;
  reg  [5:0]   data_0_sqPtr_value;
  reg          data_0_vecValid;
  reg          data_0_sqNeedDeq;
  reg  [47:0]  data_1_addr;
  reg  [49:0]  data_1_vaddr;
  reg  [127:0] data_1_data;
  reg  [15:0]  data_1_mask;
  reg          data_1_wline;
  reg  [5:0]   data_1_sqPtr_value;
  reg          data_1_vecValid;
  reg          data_1_sqNeedDeq;
  reg          valids_0;
  reg          valids_1;
  reg          enq_flag;
  reg          deq_flag;
  wire         io_deq_0_valid_0 = deq_flag ? valids_1 : valids_0;
  wire         _deq_flag_T_4 = 1'(deq_flag - 1'h1);
  wire         io_deq_1_valid_0 =
    (_deq_flag_T_4 ? valids_1 : valids_0) & io_deq_0_valid_0;
  wire         _entry_allowin_1_T_1 = io_deq_0_ready & io_deq_0_valid_0;
  wire         _entry_allowin_1_T_6 = io_deq_1_ready & io_deq_1_valid_0;
  wire         entry_allowin_0 =
    ~valids_0 | _entry_allowin_1_T_1 & ~deq_flag | _entry_allowin_1_T_6 & ~_deq_flag_T_4;
  wire         entry_allowin_1 =
    ~valids_1 | _entry_allowin_1_T_1 & deq_flag | _entry_allowin_1_T_6 & _deq_flag_T_4;
  wire         io_enq_0_ready_0 = enq_flag ? entry_allowin_1 : entry_allowin_0;
  wire         _enq_flag_T_4 = 1'(enq_flag - 1'h1);
  wire         io_enq_1_ready_0 =
    (_enq_flag_T_4 ? entry_allowin_1 : entry_allowin_0) & io_enq_0_ready_0;
  wire         _GEN = io_enq_0_ready_0 & io_enq_0_valid;
  wire         _GEN_0 = _GEN & ~enq_flag;
  wire         _GEN_1 = _GEN & enq_flag;
  wire         _GEN_2 = io_enq_1_ready_0 & io_enq_1_valid;
  always @(posedge clock) begin
    if (_GEN_2 & ~_enq_flag_T_4) begin
      data_0_addr <= io_enq_1_bits_addr;
      data_0_vaddr <= io_enq_1_bits_vaddr;
      data_0_data <= io_enq_1_bits_data;
      data_0_mask <= io_enq_1_bits_mask;
      data_0_wline <= io_enq_1_bits_wline;
      data_0_sqPtr_value <= io_enq_1_bits_sqPtr_value;
      data_0_vecValid <= io_enq_1_bits_vecValid;
      data_0_sqNeedDeq <= io_enq_1_bits_sqNeedDeq;
    end
    else begin
      if (_GEN_0) begin
        data_0_addr <= io_enq_0_bits_addr;
        data_0_vaddr <= io_enq_0_bits_vaddr;
        data_0_data <= io_enq_0_bits_data;
        data_0_mask <= io_enq_0_bits_mask;
        data_0_wline <= io_enq_0_bits_wline;
        data_0_sqPtr_value <= io_enq_0_bits_sqPtr_value;
        data_0_vecValid <= io_enq_0_bits_vecValid;
      end
      data_0_sqNeedDeq <= _GEN_0 | data_0_sqNeedDeq;
    end
    if (_GEN_2 & _enq_flag_T_4) begin
      data_1_addr <= io_enq_1_bits_addr;
      data_1_vaddr <= io_enq_1_bits_vaddr;
      data_1_data <= io_enq_1_bits_data;
      data_1_mask <= io_enq_1_bits_mask;
      data_1_wline <= io_enq_1_bits_wline;
      data_1_sqPtr_value <= io_enq_1_bits_sqPtr_value;
      data_1_vecValid <= io_enq_1_bits_vecValid;
      data_1_sqNeedDeq <= io_enq_1_bits_sqNeedDeq;
    end
    else begin
      if (_GEN_1) begin
        data_1_addr <= io_enq_0_bits_addr;
        data_1_vaddr <= io_enq_0_bits_vaddr;
        data_1_data <= io_enq_0_bits_data;
        data_1_mask <= io_enq_0_bits_mask;
        data_1_wline <= io_enq_0_bits_wline;
        data_1_sqPtr_value <= io_enq_0_bits_sqPtr_value;
        data_1_vecValid <= io_enq_0_bits_vecValid;
      end
      data_1_sqNeedDeq <= _GEN_1 | data_1_sqNeedDeq;
    end
  end // always @(posedge)
  wire         _GEN_3 = _entry_allowin_1_T_1 & ~deq_flag;
  wire         _GEN_4 = _entry_allowin_1_T_1 & deq_flag;
  wire         _GEN_5 =
    _entry_allowin_1_T_6 ? ~(~_deq_flag_T_4 | _GEN_3) & valids_0 : ~_GEN_3 & valids_0;
  wire         _GEN_6 =
    _entry_allowin_1_T_6 ? ~(_deq_flag_T_4 | _GEN_4) & valids_1 : ~_GEN_4 & valids_1;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      valids_0 <= 1'h0;
      valids_1 <= 1'h0;
      enq_flag <= 1'h0;
      deq_flag <= 1'h0;
    end
    else begin
      if (_GEN_2) begin
        valids_0 <= ~_enq_flag_T_4 | _GEN_0 | _GEN_5;
        valids_1 <= _enq_flag_T_4 | _GEN_1 | _GEN_6;
      end
      else begin
        valids_0 <= _GEN_0 | _GEN_5;
        valids_1 <= _GEN_1 | _GEN_6;
      end
      if (_GEN_2 | ~_GEN) begin
      end
      else
        enq_flag <= 1'(enq_flag - 1'h1);
      if (_entry_allowin_1_T_6 | ~_entry_allowin_1_T_1) begin
      end
      else
        deq_flag <= 1'(deq_flag - 1'h1);
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:15];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [4:0] i = 5'h0; i < 5'h10; i += 5'h1) begin
          _RANDOM[i[3:0]] = `RANDOM;
        end
        data_0_addr = {_RANDOM[4'h0], _RANDOM[4'h1][15:0]};
        data_0_vaddr = {_RANDOM[4'h1][31:16], _RANDOM[4'h2], _RANDOM[4'h3][1:0]};
        data_0_data =
          {_RANDOM[4'h3][31:2],
           _RANDOM[4'h4],
           _RANDOM[4'h5],
           _RANDOM[4'h6],
           _RANDOM[4'h7][1:0]};
        data_0_mask = _RANDOM[4'h7][17:2];
        data_0_wline = _RANDOM[4'h7][18];
        data_0_sqPtr_value = _RANDOM[4'h7][25:20];
        data_0_vecValid = _RANDOM[4'h7][27];
        data_0_sqNeedDeq = _RANDOM[4'h7][28];
        data_1_addr = {_RANDOM[4'h7][31:29], _RANDOM[4'h8], _RANDOM[4'h9][12:0]};
        data_1_vaddr = {_RANDOM[4'h9][31:13], _RANDOM[4'hA][30:0]};
        data_1_data =
          {_RANDOM[4'hA][31],
           _RANDOM[4'hB],
           _RANDOM[4'hC],
           _RANDOM[4'hD],
           _RANDOM[4'hE][30:0]};
        data_1_mask = {_RANDOM[4'hE][31], _RANDOM[4'hF][14:0]};
        data_1_wline = _RANDOM[4'hF][15];
        data_1_sqPtr_value = _RANDOM[4'hF][22:17];
        data_1_vecValid = _RANDOM[4'hF][24];
        data_1_sqNeedDeq = _RANDOM[4'hF][25];
        valids_0 = _RANDOM[4'hF][26];
        valids_1 = _RANDOM[4'hF][27];
        enq_flag = _RANDOM[4'hF][28];
        deq_flag = _RANDOM[4'hF][29];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        valids_0 = 1'h0;
        valids_1 = 1'h0;
        enq_flag = 1'h0;
        deq_flag = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_enq_0_ready = io_enq_0_ready_0;
  assign io_enq_1_ready = io_enq_1_ready_0;
  assign io_deq_0_valid = io_deq_0_valid_0;
  assign io_deq_0_bits_addr = deq_flag ? data_1_addr : data_0_addr;
  assign io_deq_0_bits_vaddr = deq_flag ? data_1_vaddr : data_0_vaddr;
  assign io_deq_0_bits_data = deq_flag ? data_1_data : data_0_data;
  assign io_deq_0_bits_mask = deq_flag ? data_1_mask : data_0_mask;
  assign io_deq_0_bits_wline = deq_flag ? data_1_wline : data_0_wline;
  assign io_deq_0_bits_sqPtr_value = deq_flag ? data_1_sqPtr_value : data_0_sqPtr_value;
  assign io_deq_0_bits_vecValid = deq_flag ? data_1_vecValid : data_0_vecValid;
  assign io_deq_0_bits_sqNeedDeq = deq_flag ? data_1_sqNeedDeq : data_0_sqNeedDeq;
  assign io_deq_1_valid = io_deq_1_valid_0;
  assign io_deq_1_bits_addr = _deq_flag_T_4 ? data_1_addr : data_0_addr;
  assign io_deq_1_bits_vaddr = _deq_flag_T_4 ? data_1_vaddr : data_0_vaddr;
  assign io_deq_1_bits_data = _deq_flag_T_4 ? data_1_data : data_0_data;
  assign io_deq_1_bits_mask = _deq_flag_T_4 ? data_1_mask : data_0_mask;
  assign io_deq_1_bits_wline = _deq_flag_T_4 ? data_1_wline : data_0_wline;
  assign io_deq_1_bits_sqPtr_value =
    _deq_flag_T_4 ? data_1_sqPtr_value : data_0_sqPtr_value;
  assign io_deq_1_bits_vecValid = _deq_flag_T_4 ? data_1_vecValid : data_0_vecValid;
  assign io_deq_1_bits_sqNeedDeq = _deq_flag_T_4 ? data_1_sqNeedDeq : data_0_sqNeedDeq;
endmodule

