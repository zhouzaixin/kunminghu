// Generated by CIRCT firtool-1.62.1
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

module FloatAdderF32F16MixedPipeline(
  input         clock,
  input         io_fire,
  input  [31:0] io_fp_a,
  input  [31:0] io_fp_b,
  output [31:0] io_fp_c,
  input         io_is_sub,
  input  [2:0]  io_round_mode,
  output [4:0]  io_fflags,
  input  [1:0]  io_fp_format,
  input  [4:0]  io_op_code,
  input         io_fp_aIsFpCanonicalNAN,
  input         io_fp_bIsFpCanonicalNAN
);

  wire [31:0] _U_close_path_io_fp_c;
  wire [4:0]  _U_close_path_io_fflags;
  wire [24:0] _U_close_path_io_CS1;
  wire [31:0] _U_far_path_io_fp_c;
  wire [4:0]  _U_far_path_io_fflags;
  wire [7:0]  _U_far_path_io_absEaSubEb;
  wire        _U_far_path_io_isEfp_bGreater;
  wire [31:0] fp_a_to32 =
    io_fp_format[0] ? io_fp_a : {io_fp_a[15], 3'h0, io_fp_a[14:0], 13'h0};
  wire [31:0] fp_b_to32 =
    io_fp_format[0] ? io_fp_b : {io_fp_b[15], 3'h0, io_fp_b[14:0], 13'h0};
  reg         is_far_path_reg;
  reg         r;
  reg         r_1;
  reg         res_is_f32_reg;
  reg         fadd0_result0_r;
  reg  [16:0] fadd0_result0_r_1;
  reg  [31:0] fadd0_result1_r;
  reg  [31:0] fadd0_result1_r_1;
  reg         out_infinite_sign_reg;
  wire [31:0] out_fp32_reg =
    is_far_path_reg ? _U_far_path_io_fp_c : _U_close_path_io_fp_c;
  reg         r_2;
  reg         r_3;
  reg         r_4;
  reg         r_5;
  reg         r_6;
  reg  [31:0] float_adder_result_r;
  reg         io_fp_c_r;
  reg  [31:0] io_fp_c_r_1;
  reg         io_fflags_r;
  reg  [4:0]  io_fflags_r_1;
  wire        EOP = fp_a_to32[31] ^ io_is_sub ^ fp_b_to32[31];
  wire        Efp_a_is_zero =
    fp_a_to32[30:23] == 8'h0 | ~(io_fp_format[0]) & fp_a_to32[30:23] == 8'h66;
  wire        Efp_b_is_zero =
    fp_b_to32[30:23] == 8'h0 | ~(io_fp_format[0]) & fp_b_to32[30:23] == 8'h66;
  wire        Efp_a_is_all_one =
    io_fp_format[0] ? (&(io_fp_a[30:23])) : (&(io_fp_a[14:10]));
  wire        Efp_b_is_all_one =
    io_fp_format[0] ? (&(io_fp_b[30:23])) : (&(io_fp_b[14:10]));
  wire        fp_a_is_NAN =
    io_fp_aIsFpCanonicalNAN | Efp_a_is_all_one & (|(fp_a_to32[22:0]));
  wire        fp_a_is_SNAN =
    ~io_fp_aIsFpCanonicalNAN & Efp_a_is_all_one & (|(fp_a_to32[22:0])) & ~(fp_a_to32[22]);
  wire        fp_b_is_NAN =
    io_fp_bIsFpCanonicalNAN | Efp_b_is_all_one & (|(fp_b_to32[22:0]));
  wire        fp_a_is_infinite =
    ~io_fp_aIsFpCanonicalNAN & Efp_a_is_all_one & ~(|(fp_a_to32[22:0]));
  wire        fp_b_is_infinite =
    ~io_fp_bIsFpCanonicalNAN & Efp_b_is_all_one & ~(|(fp_b_to32[22:0]));
  wire        fp_a_is_zero =
    ~io_fp_aIsFpCanonicalNAN & Efp_a_is_zero & ~(|(fp_a_to32[22:0]));
  wire        fp_b_is_zero =
    ~io_fp_bIsFpCanonicalNAN & Efp_b_is_zero & ~(|(fp_b_to32[22:0]));
  wire        _fflags_NV_stage0_T_15 =
    fp_a_is_SNAN | ~io_fp_bIsFpCanonicalNAN & Efp_b_is_all_one & (|(fp_b_to32[22:0]))
    & ~(fp_b_to32[22]);
  wire        _GEN = EOP & fp_a_is_infinite & fp_b_is_infinite;
  wire        _fadd0_result0_T_3 = io_round_mode == 3'h2 & EOP | fp_a_to32[31] & ~EOP;
  wire        _fflags_NV_stage0_T_7 = fp_a_is_NAN | fp_b_is_NAN;
  wire        is_min = io_op_code == 5'h2;
  wire        is_max = io_op_code == 5'h3;
  wire        is_feq = io_op_code == 5'h9;
  wire        is_flt = io_op_code == 5'hB;
  wire        is_fle = io_op_code == 5'hC;
  wire        is_fminm = io_op_code == 5'h1E;
  wire        is_fmaxm = io_op_code == 5'h13;
  wire        is_fleq = io_op_code == 5'h1C;
  wire        is_fltq = io_op_code == 5'h1B;
  wire        fp_b_exponent_is_equal = fp_a_to32[30:23] == fp_b_to32[30:23];
  wire        fp_b_significand_is_greater =
    ~(_U_close_path_io_CS1[24]) & fp_a_to32[22:0] != fp_b_to32[22:0];
  wire        fp_b_significand_is_equal = fp_a_to32[22:0] == fp_b_to32[22:0];
  wire        _fp_b_is_equal_T_2 = fp_b_is_zero & fp_a_is_zero;
  wire        fp_b_is_greater =
    ~(fp_b_to32[31])
    & (fp_a_to32[31] & ~_fp_b_is_equal_T_2 | _U_far_path_io_isEfp_bGreater
       | fp_b_exponent_is_equal & fp_b_significand_is_greater) | fp_b_to32[31]
    & fp_a_to32[31]
    & (~_U_far_path_io_isEfp_bGreater & ~fp_b_exponent_is_equal | fp_b_exponent_is_equal
       & ~fp_b_significand_is_greater & ~fp_b_significand_is_equal);
  wire        fp_b_is_equal =
    fp_a_to32[31] == fp_b_to32[31] & fp_b_exponent_is_equal & fp_b_significand_is_equal
    | _fp_b_is_equal_T_2;
  wire        fp_b_is_less = ~fp_b_is_greater & ~fp_b_is_equal;
  wire [31:0] in_NAN = io_fp_format[0] ? 32'h7FC00000 : 32'h7E00;
  wire [31:0] fp_aFix = io_fp_aIsFpCanonicalNAN ? in_NAN : io_fp_a;
  wire [31:0] fp_bFix = io_fp_bIsFpCanonicalNAN ? in_NAN : io_fp_b;
  wire [31:0] out_NAN = io_fp_format[0] ? 32'h7FC00000 : 32'h7E00;
  wire [31:0] fp_a_16_or_32 =
    io_fp_format[0]
      ? (io_fp_aIsFpCanonicalNAN ? 32'h7FC00000 : io_fp_a)
      : {16'h0, fp_aFix[15:0]};
  wire [31:0] fp_b_16_or_32 =
    io_fp_format[0]
      ? (io_fp_bIsFpCanonicalNAN ? 32'h7FC00000 : io_fp_b)
      : {16'h0, fp_bFix[15:0]};
  wire        _result_max_T_7 = fp_a_is_NAN & fp_b_is_NAN;
  wire        _GEN_0 = fp_a_is_NAN | fp_b_is_NAN;
  wire        _result_fclass_T_7 = fp_a_to32[31] & Efp_a_is_zero;
  wire        _io_fflags_T = io_op_code == 5'h0 | io_op_code == 5'h1;
  always @(posedge clock) begin
    if (io_fire) begin
      is_far_path_reg <=
        ~EOP | EOP & (|(_U_far_path_io_absEaSubEb[7:1]))
        | _U_far_path_io_absEaSubEb == 8'h1 & (Efp_a_is_zero ^ Efp_b_is_zero);
      r <= _fflags_NV_stage0_T_15 | _GEN;
      r_1 <=
        fp_a_is_NAN | fp_b_is_NAN | fp_a_is_infinite | fp_b_is_infinite | fp_b_is_zero
        | fp_a_is_zero;
      res_is_f32_reg <= io_fp_format[0];
      fadd0_result0_r <= _fadd0_result0_T_3;
      fadd0_result0_r_1 <= {17{_fadd0_result0_T_3}};
      fadd0_result1_r <= {io_is_sub ^ io_fp_b[31], io_fp_b[30:0]};
      fadd0_result1_r_1 <= {16'h0, io_is_sub ^ io_fp_b[15], io_fp_b[14:0]};
      out_infinite_sign_reg <=
        fp_a_is_infinite ? fp_a_to32[31] : io_is_sub ^ fp_b_to32[31];
      r_2 <= _fflags_NV_stage0_T_7 | _GEN;
      r_3 <= fp_a_is_infinite | fp_b_is_infinite;
      r_4 <= fp_a_is_zero & fp_b_is_zero;
      r_5 <= fp_a_is_zero;
      r_6 <= fp_b_is_zero;
      float_adder_result_r <= io_fp_a;
      io_fp_c_r <= _io_fflags_T;
      io_fp_c_r_1 <=
        (is_min
           ? (_GEN_0
                ? 32'h0
                : fp_b_is_less | fp_b_to32[31] & fp_b_is_zero & fp_a_is_zero
                    ? fp_b_16_or_32
                    : fp_a_16_or_32)
             | (~fp_a_is_NAN & fp_b_is_NAN ? fp_a_16_or_32 : 32'h0)
             | (fp_a_is_NAN & ~fp_b_is_NAN ? fp_b_16_or_32 : 32'h0)
             | (_result_max_T_7 ? out_NAN : 32'h0)
           : 32'h0)
        | (is_max
             ? (_GEN_0
                  ? 32'h0
                  : fp_b_is_greater | ~(fp_b_to32[31]) & fp_b_is_zero & fp_a_is_zero
                      ? fp_b_16_or_32
                      : fp_a_16_or_32)
               | (~fp_a_is_NAN & fp_b_is_NAN ? fp_a_16_or_32 : 32'h0)
               | (fp_a_is_NAN & ~fp_b_is_NAN ? fp_b_16_or_32 : 32'h0)
               | (_result_max_T_7 ? out_NAN : 32'h0)
             : 32'h0) | (is_feq ? {31'h0, ~_fflags_NV_stage0_T_7 & fp_b_is_equal} : 32'h0)
        | (is_flt | is_fltq ? {31'h0, ~_fflags_NV_stage0_T_7 & fp_b_is_greater} : 32'h0)
        | (is_fle | is_fleq
             ? {31'h0, ~_fflags_NV_stage0_T_7 & (fp_b_is_greater | fp_b_is_equal)}
             : 32'h0)
        | (io_op_code == 5'h6
             ? (io_fp_format[0]
                  ? {fp_bFix[31], fp_aFix[30:0]}
                  : {16'h0, fp_bFix[15], fp_aFix[14:0]})
             : 32'h0)
        | (io_op_code == 5'h7
             ? (io_fp_format[0]
                  ? {~(fp_bFix[31]), fp_aFix[30:0]}
                  : {16'h0, ~(fp_bFix[15]), fp_aFix[14:0]})
             : 32'h0)
        | (io_op_code == 5'h8
             ? (io_fp_format[0]
                  ? {fp_bFix[31] ^ fp_aFix[31], fp_aFix[30:0]}
                  : {16'h0, fp_bFix[15] ^ fp_aFix[15], fp_aFix[14:0]})
             : 32'h0)
        | (io_op_code == 5'hF
             ? {22'h0,
                io_fp_aIsFpCanonicalNAN
                  ? 10'h200
                  : {fp_a_is_NAN & ~fp_a_is_SNAN,
                     fp_a_is_SNAN,
                     ~(fp_a_to32[31]) & fp_a_is_infinite,
                     ~(fp_a_to32[31]) & ~Efp_a_is_zero & ~Efp_a_is_all_one,
                     ~(fp_a_to32[31]) & Efp_a_is_zero & (|(fp_a_to32[22:0])),
                     ~(fp_a_to32[31]) & Efp_a_is_zero & ~(|(fp_a_to32[22:0])),
                     _result_fclass_T_7 & ~(|(fp_a_to32[22:0])),
                     _result_fclass_T_7 & (|(fp_a_to32[22:0])),
                     fp_a_to32[31] & ~Efp_a_is_zero & ~Efp_a_is_all_one,
                     fp_a_to32[31] & fp_a_is_infinite}}
             : 32'h0)
        | (is_fminm
             ? (_GEN_0
                  ? out_NAN
                  : fp_b_is_less | fp_b_to32[31] & fp_b_is_zero & fp_a_is_zero
                      ? fp_b_16_or_32
                      : fp_a_16_or_32)
             : 32'h0)
        | (is_fmaxm
             ? (_GEN_0
                  ? out_NAN
                  : fp_b_is_greater | ~(fp_b_to32[31]) & fp_b_is_zero & fp_a_is_zero
                      ? fp_b_16_or_32
                      : fp_a_16_or_32)
             : 32'h0);
      io_fflags_r <= _io_fflags_T;
      io_fflags_r_1 <=
        {(is_min | is_max) & _fflags_NV_stage0_T_15 | is_feq & _fflags_NV_stage0_T_15
           | (is_flt | is_fle) & _fflags_NV_stage0_T_7 | (is_fminm | is_fmaxm)
           & _fflags_NV_stage0_T_15 | (is_fltq | is_fleq) & _fflags_NV_stage0_T_15,
         4'h0};
    end
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:5];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [2:0] i = 3'h0; i < 3'h6; i += 3'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        is_far_path_reg = _RANDOM[3'h0][0];
        r = _RANDOM[3'h0][1];
        r_1 = _RANDOM[3'h0][2];
        res_is_f32_reg = _RANDOM[3'h0][3];
        fadd0_result0_r = _RANDOM[3'h0][4];
        fadd0_result0_r_1 = _RANDOM[3'h0][21:5];
        fadd0_result1_r = {_RANDOM[3'h0][31:22], _RANDOM[3'h1][21:0]};
        fadd0_result1_r_1 = {_RANDOM[3'h1][31:22], _RANDOM[3'h2][21:0]};
        out_infinite_sign_reg = _RANDOM[3'h2][22];
        r_2 = _RANDOM[3'h2][23];
        r_3 = _RANDOM[3'h2][24];
        r_4 = _RANDOM[3'h2][25];
        r_5 = _RANDOM[3'h2][26];
        r_6 = _RANDOM[3'h2][27];
        float_adder_result_r = {_RANDOM[3'h2][31:28], _RANDOM[3'h3][27:0]};
        io_fp_c_r = _RANDOM[3'h3][28];
        io_fp_c_r_1 = {_RANDOM[3'h3][31:29], _RANDOM[3'h4][28:0]};
        io_fflags_r = _RANDOM[3'h4][29];
        io_fflags_r_1 = {_RANDOM[3'h4][31:30], _RANDOM[3'h5][2:0]};
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  FarPathF32WidenF16MixedPipeline U_far_path (
    .clock             (clock),
    .io_fire           (io_fire),
    .io_fp_a           (fp_a_to32),
    .io_fp_b           (fp_b_to32),
    .io_fp_c           (_U_far_path_io_fp_c),
    .io_is_sub         (io_is_sub),
    .io_round_mode     (io_round_mode),
    .io_fflags         (_U_far_path_io_fflags),
    .io_absEaSubEb     (_U_far_path_io_absEaSubEb),
    .io_res_is_f32     (io_fp_format[0]),
    .io_isEfp_bGreater (_U_far_path_io_isEfp_bGreater)
  );
  ClosePathF32WidenF16MixedPipeline U_close_path (
    .clock         (clock),
    .io_fire       (io_fire),
    .io_fp_a       (fp_a_to32),
    .io_fp_b       (fp_b_to32),
    .io_fp_c       (_U_close_path_io_fp_c),
    .io_round_mode (io_round_mode),
    .io_fflags     (_U_close_path_io_fflags),
    .io_res_is_f32 (io_fp_format[0]),
    .io_CS1        (_U_close_path_io_CS1)
  );
  assign io_fp_c =
    io_fp_c_r
      ? (r_2
           ? (res_is_f32_reg ? 32'h7FC00000 : 32'h7E00)
           : r_3
               ? (res_is_f32_reg
                    ? {out_infinite_sign_reg, 31'h7F800000}
                    : {16'h0, out_infinite_sign_reg, 15'h7C00})
               : r_4
                   ? (res_is_f32_reg
                        ? {fadd0_result0_r, 31'h0}
                        : {fadd0_result0_r_1, 15'h0})
                   : r_5
                       ? (res_is_f32_reg ? fadd0_result1_r : fadd0_result1_r_1)
                       : r_6
                           ? float_adder_result_r
                           : res_is_f32_reg
                               ? out_fp32_reg
                               : {16'h0, out_fp32_reg[31], out_fp32_reg[27:13]})
      : io_fp_c_r_1;
  assign io_fflags =
    io_fflags_r
      ? (r
           ? 5'h10
           : r_1
               ? 5'h0
               : is_far_path_reg ? _U_far_path_io_fflags : _U_close_path_io_fflags)
      : io_fflags_r_1;
endmodule

