// Generated by CIRCT firtool-1.62.1
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

module VTypeGen(
  input         clock,
  input         reset,
  input         io_insts_0_valid,
  input  [31:0] io_insts_0_bits,
  input         io_insts_1_valid,
  input  [31:0] io_insts_1_bits,
  input         io_insts_2_valid,
  input  [31:0] io_insts_2_bits,
  input         io_insts_3_valid,
  input  [31:0] io_insts_3_bits,
  input         io_insts_4_valid,
  input  [31:0] io_insts_4_bits,
  input         io_insts_5_valid,
  input  [31:0] io_insts_5_bits,
  input         io_walkToArchVType,
  input         io_walkVType_valid,
  input         io_walkVType_bits_illegal,
  input         io_walkVType_bits_vma,
  input         io_walkVType_bits_vta,
  input  [1:0]  io_walkVType_bits_vsew,
  input  [2:0]  io_walkVType_bits_vlmul,
  input         io_canUpdateVType,
  output        io_vtype_illegal,
  output        io_vtype_vma,
  output        io_vtype_vta,
  output [1:0]  io_vtype_vsew,
  output [2:0]  io_vtype_vlmul,
  input         io_vsetvlVType_illegal,
  input         io_vsetvlVType_vma,
  input         io_vsetvlVType_vta,
  input  [1:0]  io_vsetvlVType_vsew,
  input  [2:0]  io_vsetvlVType_vlmul,
  input         io_commitVType_vtype_valid,
  input         io_commitVType_vtype_bits_illegal,
  input         io_commitVType_vtype_bits_vma,
  input         io_commitVType_vtype_bits_vta,
  input  [1:0]  io_commitVType_vtype_bits_vsew,
  input  [2:0]  io_commitVType_vtype_bits_vlmul,
  input         io_commitVType_hasVsetvl
);

  wire        _vsetModule_io_out_vconfig_vtype_illegal;
  wire        _vsetModule_io_out_vconfig_vtype_vma;
  wire        _vsetModule_io_out_vconfig_vtype_vta;
  wire [1:0]  _vsetModule_io_out_vconfig_vtype_vsew;
  wire [2:0]  _vsetModule_io_out_vconfig_vtype_vlmul;
  wire        isVsetVec_0 =
    io_insts_0_valid & io_insts_0_bits[6:0] == 7'h57 & (&(io_insts_0_bits[14:12]))
    & (~(io_insts_0_bits[31]) | (&(io_insts_0_bits[31:30])));
  wire        isVsetVec_1 =
    io_insts_1_valid & io_insts_1_bits[6:0] == 7'h57 & (&(io_insts_1_bits[14:12]))
    & (~(io_insts_1_bits[31]) | (&(io_insts_1_bits[31:30])));
  wire        isVsetVec_2 =
    io_insts_2_valid & io_insts_2_bits[6:0] == 7'h57 & (&(io_insts_2_bits[14:12]))
    & (~(io_insts_2_bits[31]) | (&(io_insts_2_bits[31:30])));
  wire        isVsetVec_3 =
    io_insts_3_valid & io_insts_3_bits[6:0] == 7'h57 & (&(io_insts_3_bits[14:12]))
    & (~(io_insts_3_bits[31]) | (&(io_insts_3_bits[31:30])));
  wire        isVsetVec_4 =
    io_insts_4_valid & io_insts_4_bits[6:0] == 7'h57 & (&(io_insts_4_bits[14:12]))
    & (~(io_insts_4_bits[31]) | (&(io_insts_4_bits[31:30])));
  wire        isVsetVec_5 =
    io_insts_5_valid & io_insts_5_bits[6:0] == 7'h57 & (&(io_insts_5_bits[14:12]))
    & (~(io_insts_5_bits[31]) | (&(io_insts_5_bits[31:30])));
  wire [4:0]  firstVsetOH_enc =
    isVsetVec_0
      ? 5'h1
      : isVsetVec_1
          ? 5'h2
          : isVsetVec_2 ? 5'h4 : isVsetVec_3 ? 5'h8 : {isVsetVec_4, 4'h0};
  wire [31:0] firstVsetInstField_inst =
    firstVsetOH_enc[0]
      ? io_insts_0_bits
      : firstVsetOH_enc[1]
          ? io_insts_1_bits
          : firstVsetOH_enc[2]
              ? io_insts_2_bits
              : firstVsetOH_enc[3]
                  ? io_insts_3_bits
                  : firstVsetOH_enc[4] ? io_insts_4_bits : io_insts_5_bits;
  wire        isVsetvli =
    firstVsetInstField_inst[6:0] == 7'h57 & (&(firstVsetInstField_inst[14:12]))
    & ~(firstVsetInstField_inst[31]);
  reg         vtypeArch_illegal;
  reg         vtypeArch_vma;
  reg         vtypeArch_vta;
  reg  [1:0]  vtypeArch_vsew;
  reg  [2:0]  vtypeArch_vlmul;
  reg         vtypeSpec_illegal;
  reg         vtypeSpec_vma;
  reg         vtypeSpec_vta;
  reg  [1:0]  vtypeSpec_vsew;
  reg  [2:0]  vtypeSpec_vlmul;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      vtypeArch_illegal <= 1'h1;
      vtypeArch_vma <= 1'h0;
      vtypeArch_vta <= 1'h0;
      vtypeArch_vsew <= 2'h0;
      vtypeArch_vlmul <= 3'h0;
      vtypeSpec_illegal <= 1'h1;
      vtypeSpec_vma <= 1'h0;
      vtypeSpec_vta <= 1'h0;
      vtypeSpec_vsew <= 2'h0;
      vtypeSpec_vlmul <= 3'h0;
    end
    else if (io_commitVType_hasVsetvl) begin
      vtypeArch_illegal <= io_vsetvlVType_illegal;
      vtypeArch_vma <= io_vsetvlVType_vma;
      vtypeArch_vta <= io_vsetvlVType_vta;
      vtypeArch_vsew <= io_vsetvlVType_vsew;
      vtypeArch_vlmul <= io_vsetvlVType_vlmul;
      vtypeSpec_illegal <= io_vsetvlVType_illegal;
      vtypeSpec_vma <= io_vsetvlVType_vma;
      vtypeSpec_vta <= io_vsetvlVType_vta;
      vtypeSpec_vsew <= io_vsetvlVType_vsew;
      vtypeSpec_vlmul <= io_vsetvlVType_vlmul;
    end
    else begin
      if (io_commitVType_vtype_valid) begin
        vtypeArch_illegal <= io_commitVType_vtype_bits_illegal;
        vtypeArch_vma <= io_commitVType_vtype_bits_vma;
        vtypeArch_vta <= io_commitVType_vtype_bits_vta;
        vtypeArch_vsew <= io_commitVType_vtype_bits_vsew;
        vtypeArch_vlmul <= io_commitVType_vtype_bits_vlmul;
      end
      if (io_walkVType_valid) begin
        vtypeSpec_illegal <= io_walkVType_bits_illegal;
        vtypeSpec_vma <= io_walkVType_bits_vma;
        vtypeSpec_vta <= io_walkVType_bits_vta;
        vtypeSpec_vsew <= io_walkVType_bits_vsew;
        vtypeSpec_vlmul <= io_walkVType_bits_vlmul;
      end
      else if (io_walkToArchVType) begin
        vtypeSpec_illegal <= vtypeArch_illegal;
        vtypeSpec_vma <= vtypeArch_vma;
        vtypeSpec_vta <= vtypeArch_vta;
        vtypeSpec_vsew <= vtypeArch_vsew;
        vtypeSpec_vlmul <= vtypeArch_vlmul;
      end
      else if ((|{isVsetVec_5,
                  isVsetVec_4,
                  isVsetVec_3,
                  isVsetVec_2,
                  isVsetVec_1,
                  isVsetVec_0}) & io_canUpdateVType) begin
        vtypeSpec_illegal <= _vsetModule_io_out_vconfig_vtype_illegal;
        vtypeSpec_vma <= _vsetModule_io_out_vconfig_vtype_vma;
        vtypeSpec_vta <= _vsetModule_io_out_vconfig_vtype_vta;
        vtypeSpec_vsew <= _vsetModule_io_out_vconfig_vtype_vsew;
        vtypeSpec_vlmul <= _vsetModule_io_out_vconfig_vtype_vlmul;
      end
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        vtypeArch_illegal = _RANDOM[/*Zero width*/ 1'b0][0];
        vtypeArch_vma = _RANDOM[/*Zero width*/ 1'b0][1];
        vtypeArch_vta = _RANDOM[/*Zero width*/ 1'b0][2];
        vtypeArch_vsew = _RANDOM[/*Zero width*/ 1'b0][4:3];
        vtypeArch_vlmul = _RANDOM[/*Zero width*/ 1'b0][7:5];
        vtypeSpec_illegal = _RANDOM[/*Zero width*/ 1'b0][8];
        vtypeSpec_vma = _RANDOM[/*Zero width*/ 1'b0][9];
        vtypeSpec_vta = _RANDOM[/*Zero width*/ 1'b0][10];
        vtypeSpec_vsew = _RANDOM[/*Zero width*/ 1'b0][12:11];
        vtypeSpec_vlmul = _RANDOM[/*Zero width*/ 1'b0][15:13];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        vtypeArch_illegal = 1'h1;
        vtypeArch_vma = 1'h0;
        vtypeArch_vta = 1'h0;
        vtypeArch_vsew = 2'h0;
        vtypeArch_vlmul = 3'h0;
        vtypeSpec_illegal = 1'h1;
        vtypeSpec_vma = 1'h0;
        vtypeSpec_vta = 1'h0;
        vtypeSpec_vsew = 2'h0;
        vtypeSpec_vlmul = 3'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  VsetModule vsetModule (
    .io_in_avl                    (64'h0),
    .io_in_vtype_illegal          (1'h0),
    .io_in_vtype_reserved
      ({52'h0,
        isVsetvli
          ? firstVsetInstField_inst[30:28]
          : {1'h0, firstVsetInstField_inst[29:28]}}),
    .io_in_vtype_vma
      (isVsetvli ? firstVsetInstField_inst[27] : firstVsetInstField_inst[27]),
    .io_in_vtype_vta
      (isVsetvli ? firstVsetInstField_inst[26] : firstVsetInstField_inst[26]),
    .io_in_vtype_vsew
      (isVsetvli ? firstVsetInstField_inst[25:23] : firstVsetInstField_inst[25:23]),
    .io_in_vtype_vlmul
      (isVsetvli ? firstVsetInstField_inst[22:20] : firstVsetInstField_inst[22:20]),
    .io_in_func                   (9'hA0),
    .io_out_vconfig_vtype_illegal (_vsetModule_io_out_vconfig_vtype_illegal),
    .io_out_vconfig_vtype_vma     (_vsetModule_io_out_vconfig_vtype_vma),
    .io_out_vconfig_vtype_vta     (_vsetModule_io_out_vconfig_vtype_vta),
    .io_out_vconfig_vtype_vsew    (_vsetModule_io_out_vconfig_vtype_vsew),
    .io_out_vconfig_vtype_vlmul   (_vsetModule_io_out_vconfig_vtype_vlmul),
    .io_out_vconfig_vl            (/* unused */),
    .io_out_vlmax                 (/* unused */)
  );
  assign io_vtype_illegal = vtypeSpec_illegal;
  assign io_vtype_vma = vtypeSpec_vma;
  assign io_vtype_vta = vtypeSpec_vta;
  assign io_vtype_vsew = vtypeSpec_vsew;
  assign io_vtype_vlmul = vtypeSpec_vlmul;
endmodule

