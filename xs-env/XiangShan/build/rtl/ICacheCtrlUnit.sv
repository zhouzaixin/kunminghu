// Generated by CIRCT firtool-1.62.1
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

module ICacheCtrlUnit(
  input         clock,
  input         reset,
  output        auto_in_a_ready,
  input         auto_in_a_valid,
  input  [3:0]  auto_in_a_bits_opcode,
  input  [1:0]  auto_in_a_bits_size,
  input  [2:0]  auto_in_a_bits_source,
  input  [29:0] auto_in_a_bits_address,
  input  [7:0]  auto_in_a_bits_mask,
  input  [63:0] auto_in_a_bits_data,
  input         auto_in_d_ready,
  output        auto_in_d_valid,
  output [3:0]  auto_in_d_bits_opcode,
  output [1:0]  auto_in_d_bits_size,
  output [2:0]  auto_in_d_bits_source,
  output [63:0] auto_in_d_bits_data,
  output        io_ecc_enable,
  output        io_injecting,
  input         io_metaRead_ready,
  output        io_metaRead_valid,
  output [7:0]  io_metaRead_bits_vSetIdx_0,
  output [7:0]  io_metaRead_bits_vSetIdx_1,
  input  [35:0] io_metaReadResp_metas_0_0_tag,
  input  [35:0] io_metaReadResp_metas_0_1_tag,
  input  [35:0] io_metaReadResp_metas_0_2_tag,
  input  [35:0] io_metaReadResp_metas_0_3_tag,
  input         io_metaReadResp_entryValid_0_0,
  input         io_metaReadResp_entryValid_0_1,
  input         io_metaReadResp_entryValid_0_2,
  input         io_metaReadResp_entryValid_0_3,
  input         io_metaWrite_ready,
  output        io_metaWrite_valid,
  output [7:0]  io_metaWrite_bits_virIdx,
  output [35:0] io_metaWrite_bits_phyTag,
  output [3:0]  io_metaWrite_bits_waymask,
  output        io_metaWrite_bits_bankIdx,
  input         io_dataWrite_ready,
  output        io_dataWrite_valid,
  output [7:0]  io_dataWrite_bits_virIdx,
  output [3:0]  io_dataWrite_bits_waymask
);

  wire        _out_back_q_io_deq_valid;
  wire        _out_back_q_io_deq_bits_read;
  wire [3:0]  _out_back_q_io_deq_bits_index;
  wire [63:0] _out_back_q_io_deq_bits_data;
  wire [7:0]  _out_back_q_io_deq_bits_mask;
  reg  [2:0]  eccctrl_ierror;
  reg  [2:0]  eccctrl_istatus;
  reg  [1:0]  eccctrl_itarget;
  reg         eccctrl_enable;
  reg  [47:0] ecciaddr_paddr;
  wire        io_injecting_0 = eccctrl_istatus == 3'h1;
  reg  [3:0]  iwaymask;
  reg  [2:0]  istate;
  wire        io_metaRead_valid_0 = istate == 3'h1;
  wire        io_metaWrite_valid_0 = istate == 3'h3;
  wire        io_dataWrite_valid_0 = istate == 3'h4;
  wire        _out_T_3 = _out_back_q_io_deq_bits_index[3:1] == 3'h0;
  wire        _out_wofireMux_T = _out_back_q_io_deq_valid & auto_in_d_ready;
  wire        _out_wofireMux_T_2 = _out_wofireMux_T & ~_out_back_q_io_deq_bits_read;
  wire        _GEN = istate == 3'h0;
  wire        _GEN_0 = istate == 3'h1;
  wire        _GEN_1 = istate == 3'h2;
  wire [3:0]  waymask =
    {io_metaReadResp_entryValid_0_3
       & io_metaReadResp_metas_0_3_tag == ecciaddr_paddr[47:12],
     io_metaReadResp_entryValid_0_2
       & io_metaReadResp_metas_0_2_tag == ecciaddr_paddr[47:12],
     io_metaReadResp_entryValid_0_1
       & io_metaReadResp_metas_0_1_tag == ecciaddr_paddr[47:12],
     io_metaReadResp_entryValid_0_0
       & io_metaReadResp_metas_0_0_tag == ecciaddr_paddr[47:12]};
  wire        _GEN_2 = _GEN | _GEN_0;
  wire        _GEN_3 = waymask == 4'h0;
  wire        _GEN_4 = _GEN_2 | ~(_GEN_1 & _GEN_3);
  wire        _GEN_5 =
    istate == 3'h3
      ? io_metaWrite_ready & io_metaWrite_valid_0
      : istate == 3'h4 & io_dataWrite_ready & io_dataWrite_valid_0;
  wire [63:0] out_backMask =
    {{8{_out_back_q_io_deq_bits_mask[7]}},
     {8{_out_back_q_io_deq_bits_mask[6]}},
     {8{_out_back_q_io_deq_bits_mask[5]}},
     {8{_out_back_q_io_deq_bits_mask[4]}},
     {8{_out_back_q_io_deq_bits_mask[3]}},
     {8{_out_back_q_io_deq_bits_mask[2]}},
     {8{_out_back_q_io_deq_bits_mask[1]}},
     {8{_out_back_q_io_deq_bits_mask[0]}}};
  wire        out_f_woready =
    _out_wofireMux_T_2 & ~(_out_back_q_io_deq_bits_index[0]) & _out_T_3 & (&out_backMask);
  wire        _GEN_6 =
    _out_wofireMux_T & _out_back_q_io_deq_bits_read & ~(_out_back_q_io_deq_bits_index[0])
    & _out_T_3 & (|out_backMask) & (eccctrl_istatus == 3'h2 | (&eccctrl_istatus));
  wire        _out_T_13 =
    (|(_out_back_q_io_deq_bits_data[3:2])) & _out_back_q_io_deq_bits_data[3:2] != 2'h2;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      eccctrl_ierror <= 3'h0;
      eccctrl_istatus <= 3'h0;
      eccctrl_itarget <= 2'h0;
      eccctrl_enable <= 1'h1;
      ecciaddr_paddr <= 48'h0;
      iwaymask <= 4'h0;
      istate <= 3'h0;
    end
    else begin
      if (out_f_woready & _out_back_q_io_deq_bits_data[1] & eccctrl_istatus == 3'h0) begin
        if (_out_back_q_io_deq_bits_data[0]) begin
          if (_out_T_13)
            eccctrl_ierror <= 3'h1;
          else if (_GEN_6)
            eccctrl_ierror <= 3'h0;
          else if (_GEN_4) begin
          end
          else
            eccctrl_ierror <= 3'h2;
        end
        else
          eccctrl_ierror <= 3'h0;
        eccctrl_istatus <= ~(_out_back_q_io_deq_bits_data[0]) | _out_T_13 ? 3'h7 : 3'h1;
      end
      else if (_GEN_6) begin
        eccctrl_ierror <= 3'h0;
        eccctrl_istatus <= 3'h0;
      end
      else begin
        if (_GEN_4) begin
        end
        else
          eccctrl_ierror <= 3'h2;
        if (~_GEN_2) begin
          if (_GEN_1) begin
            if (_GEN_3)
              eccctrl_istatus <= 3'h7;
          end
          else if (_GEN_5)
            eccctrl_istatus <= 3'h2;
        end
      end
      if (out_f_woready) begin
        eccctrl_itarget <= _out_back_q_io_deq_bits_data[3:2];
        eccctrl_enable <= _out_back_q_io_deq_bits_data[0];
      end
      if (_out_wofireMux_T_2 & _out_back_q_io_deq_bits_index[0] & _out_T_3
          & (&out_backMask))
        ecciaddr_paddr <= _out_back_q_io_deq_bits_data[47:0];
      if (_GEN_2 | ~_GEN_1) begin
      end
      else
        iwaymask <= waymask;
      if (_GEN) begin
        if (io_injecting_0)
          istate <= 3'h1;
      end
      else if (_GEN_0) begin
        if (io_metaRead_ready & io_metaRead_valid_0)
          istate <= 3'h2;
      end
      else if (_GEN_1)
        istate <= _GEN_3 ? 3'h0 : eccctrl_itarget == 2'h0 ? 3'h3 : 3'h4;
      else if (_GEN_5)
        istate <= 3'h0;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:2];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [1:0] i = 2'h0; i < 2'h3; i += 2'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        eccctrl_ierror = _RANDOM[2'h0][2:0];
        eccctrl_istatus = _RANDOM[2'h0][5:3];
        eccctrl_itarget = _RANDOM[2'h0][7:6];
        eccctrl_enable = _RANDOM[2'h0][9];
        ecciaddr_paddr = {_RANDOM[2'h0][31:10], _RANDOM[2'h1][25:0]};
        iwaymask = _RANDOM[2'h1][29:26];
        istate = {_RANDOM[2'h1][31:30], _RANDOM[2'h2][0]};
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        eccctrl_ierror = 3'h0;
        eccctrl_istatus = 3'h0;
        eccctrl_itarget = 2'h0;
        eccctrl_enable = 1'h1;
        ecciaddr_paddr = 48'h0;
        iwaymask = 4'h0;
        istate = 3'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  Queue1_RegMapperInput_3 out_back_q (
    .clock                               (clock),
    .reset                               (reset),
    .io_enq_ready                        (auto_in_a_ready),
    .io_enq_valid                        (auto_in_a_valid),
    .io_enq_bits_read                    (auto_in_a_bits_opcode == 4'h4),
    .io_enq_bits_index                   (auto_in_a_bits_address[6:3]),
    .io_enq_bits_data                    (auto_in_a_bits_data),
    .io_enq_bits_mask                    (auto_in_a_bits_mask),
    .io_enq_bits_extra_tlrr_extra_source (auto_in_a_bits_source),
    .io_enq_bits_extra_tlrr_extra_size   (auto_in_a_bits_size),
    .io_deq_ready                        (auto_in_d_ready),
    .io_deq_valid                        (_out_back_q_io_deq_valid),
    .io_deq_bits_read                    (_out_back_q_io_deq_bits_read),
    .io_deq_bits_index                   (_out_back_q_io_deq_bits_index),
    .io_deq_bits_data                    (_out_back_q_io_deq_bits_data),
    .io_deq_bits_mask                    (_out_back_q_io_deq_bits_mask),
    .io_deq_bits_extra_tlrr_extra_source (auto_in_d_bits_source),
    .io_deq_bits_extra_tlrr_extra_size   (auto_in_d_bits_size)
  );
  assign auto_in_d_valid = _out_back_q_io_deq_valid;
  assign auto_in_d_bits_opcode = {3'h0, _out_back_q_io_deq_bits_read};
  assign auto_in_d_bits_data =
    _out_T_3
      ? (_out_back_q_io_deq_bits_index[0]
           ? {16'h0, ecciaddr_paddr}
           : {54'h0,
              eccctrl_ierror,
              eccctrl_istatus,
              eccctrl_itarget,
              1'h0,
              eccctrl_enable})
      : 64'h0;
  assign io_ecc_enable = eccctrl_enable;
  assign io_injecting = io_injecting_0;
  assign io_metaRead_valid = io_metaRead_valid_0;
  assign io_metaRead_bits_vSetIdx_0 = ecciaddr_paddr[13:6];
  assign io_metaRead_bits_vSetIdx_1 = ecciaddr_paddr[13:6];
  assign io_metaWrite_valid = io_metaWrite_valid_0;
  assign io_metaWrite_bits_virIdx = ecciaddr_paddr[13:6];
  assign io_metaWrite_bits_phyTag = ecciaddr_paddr[47:12];
  assign io_metaWrite_bits_waymask = iwaymask;
  assign io_metaWrite_bits_bankIdx = ecciaddr_paddr[6];
  assign io_dataWrite_valid = io_dataWrite_valid_0;
  assign io_dataWrite_bits_virIdx = ecciaddr_paddr[13:6];
  assign io_dataWrite_bits_waymask = iwaymask;
endmodule

