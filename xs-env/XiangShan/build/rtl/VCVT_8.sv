// Generated by CIRCT firtool-1.62.1
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

module VCVT_8(
  input          clock,
  input          reset,
  input          io_in_valid,
  input  [8:0]   io_in_bits_ctrl_fuOpType,
  input  [1:0]   io_in_bits_ctrl_vpu_vsew,
  input  [2:0]   io_in_bits_ctrl_vpu_vlmul,
  input          io_in_bits_ctrl_vpu_vm,
  input  [6:0]   io_in_bits_ctrl_vpu_vuopIdx,
  input          io_in_bits_ctrlPipe_2_robIdx_flag,
  input  [7:0]   io_in_bits_ctrlPipe_2_robIdx_value,
  input  [7:0]   io_in_bits_ctrlPipe_2_pdest,
  input          io_in_bits_ctrlPipe_2_vecWen,
  input          io_in_bits_ctrlPipe_2_v0Wen,
  input          io_in_bits_ctrlPipe_2_fpu_wflags,
  input          io_in_bits_ctrlPipe_2_vpu_vma,
  input          io_in_bits_ctrlPipe_2_vpu_vta,
  input          io_in_bits_ctrlPipe_2_vpu_vm,
  input  [7:0]   io_in_bits_ctrlPipe_2_vpu_vstart,
  input  [6:0]   io_in_bits_ctrlPipe_2_vpu_vuopIdx,
  input          io_in_bits_ctrlPipe_2_vpu_isDstMask,
  input          io_in_bits_validPipe_2,
  input  [7:0]   io_in_bits_data_src_4,
  input  [127:0] io_in_bits_data_src_3,
  input  [127:0] io_in_bits_data_src_1,
  input  [7:0]   io_in_bits_dataPipe_2_src_4,
  input  [127:0] io_in_bits_dataPipe_2_src_3,
  input  [127:0] io_in_bits_dataPipe_2_src_2,
  output         io_out_valid,
  output         io_out_bits_ctrl_robIdx_flag,
  output [7:0]   io_out_bits_ctrl_robIdx_value,
  output [7:0]   io_out_bits_ctrl_pdest,
  output         io_out_bits_ctrl_vecWen,
  output         io_out_bits_ctrl_v0Wen,
  output         io_out_bits_ctrl_fpu_wflags,
  output [127:0] io_out_bits_res_data,
  output [4:0]   io_out_bits_res_fflags,
  input  [2:0]   io_frm
);

  wire [127:0] _vfcvt_io_result;
  wire [39:0]  _vfcvt_io_fflags;
  reg          validVecThisFu_1;
  reg          validVecThisFu_2;
  wire         isRtz = io_in_bits_ctrl_fuOpType[2] & io_in_bits_ctrl_fuOpType[1];
  wire         isRod =
    io_in_bits_ctrl_fuOpType[2] & ~(io_in_bits_ctrl_fuOpType[1])
    & io_in_bits_ctrl_fuOpType[0];
  wire         isWidenCvt = ~(io_in_bits_ctrl_fuOpType[4]) & io_in_bits_ctrl_fuOpType[3];
  wire         isNarrowCvt = io_in_bits_ctrl_fuOpType[4] & ~(io_in_bits_ctrl_fuOpType[3]);
  reg          fireReg_last_r;
  wire [3:0]   output1H_invInputs =
    ~{io_in_bits_ctrl_fuOpType[4:3], io_in_bits_ctrl_vpu_vsew};
  wire [1:0]   _output1H_orMatrixOutputs_T_1 =
    {&{io_in_bits_ctrl_vpu_vsew[0], output1H_invInputs[1], output1H_invInputs[2]},
     &{output1H_invInputs[0],
       output1H_invInputs[1],
       io_in_bits_ctrl_fuOpType[3],
       output1H_invInputs[3]}};
  wire [1:0]   _output1H_orMatrixOutputs_T_3 =
    {&{output1H_invInputs[0], io_in_bits_ctrl_vpu_vsew[1], output1H_invInputs[2]},
     &{io_in_bits_ctrl_vpu_vsew[0],
       output1H_invInputs[1],
       io_in_bits_ctrl_fuOpType[3],
       output1H_invInputs[3]}};
  wire [1:0]   _output1H_orMatrixOutputs_T_5 =
    {&{io_in_bits_ctrl_vpu_vsew[0],
       io_in_bits_ctrl_vpu_vsew[1],
       output1H_invInputs[2],
       output1H_invInputs[3]},
     &{output1H_invInputs[0],
       io_in_bits_ctrl_vpu_vsew[1],
       io_in_bits_ctrl_fuOpType[3],
       output1H_invInputs[3]}};
  reg  [1:0]   outEew_r;
  reg  [1:0]   outEew;
  reg          fflagsEnCycle2_r_0;
  reg          fflagsEnCycle2_r_1;
  reg          fflagsEnCycle2_r_2;
  reg          fflagsEnCycle2_r_3;
  reg          fflagsEnCycle2_r_4;
  reg          fflagsEnCycle2_r_5;
  reg          fflagsEnCycle2_r_6;
  reg          fflagsEnCycle2_r_7;
  reg          fflagsEnCycle2_0;
  reg          fflagsEnCycle2_1;
  reg          fflagsEnCycle2_2;
  reg          fflagsEnCycle2_3;
  reg          fflagsEnCycle2_4;
  reg          fflagsEnCycle2_5;
  reg          fflagsEnCycle2_6;
  reg          fflagsEnCycle2_7;
  reg          narrow_r;
  reg          narrow;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      validVecThisFu_1 <= 1'h0;
      validVecThisFu_2 <= 1'h0;
      fireReg_last_r <= 1'h0;
    end
    else begin
      validVecThisFu_1 <= io_in_valid;
      validVecThisFu_2 <= validVecThisFu_1;
      if (io_in_valid | fireReg_last_r)
        fireReg_last_r <= io_in_valid;
    end
  end // always @(posedge, posedge)
  wire         _eNum1HEffect_T = isWidenCvt | isNarrowCvt;
  wire [2:0]   eNum1H_invInputs = ~{io_in_bits_ctrl_vpu_vsew, _eNum1HEffect_T};
  wire [1:0]   _eNum1H_orMatrixOutputs_T =
    {&{_eNum1HEffect_T, eNum1H_invInputs[1], io_in_bits_ctrl_vpu_vsew[1]},
     &{eNum1H_invInputs[0], io_in_bits_ctrl_vpu_vsew[0], io_in_bits_ctrl_vpu_vsew[1]}};
  wire [1:0]   _eNum1H_orMatrixOutputs_T_2 =
    {&{_eNum1HEffect_T, io_in_bits_ctrl_vpu_vsew[0], eNum1H_invInputs[2]},
     &{eNum1H_invInputs[0], eNum1H_invInputs[1], io_in_bits_ctrl_vpu_vsew[1]}};
  wire [1:0]   _eNum1H_orMatrixOutputs_T_4 =
    {&{_eNum1HEffect_T, eNum1H_invInputs[1], eNum1H_invInputs[2]},
     &{eNum1H_invInputs[0], io_in_bits_ctrl_vpu_vsew[0], eNum1H_invInputs[2]}};
  wire [4:0]   eNum1HEffect =
    _eNum1HEffect_T
      ? {|_eNum1H_orMatrixOutputs_T_4,
         |_eNum1H_orMatrixOutputs_T_2,
         |_eNum1H_orMatrixOutputs_T,
         2'h0}
      : {1'h0,
         |_eNum1H_orMatrixOutputs_T_4,
         |_eNum1H_orMatrixOutputs_T_2,
         |_eNum1H_orMatrixOutputs_T,
         1'h0};
  wire [7:0]   _eNumMax1H_T_8 = {3'h0, eNum1HEffect} << io_in_bits_ctrl_vpu_vlmul[1:0];
  wire [7:0]   _GEN =
    {1'h0,
     io_in_bits_ctrl_vpu_vlmul[2]
       ? {2'h0, eNum1HEffect >> 2'(~(io_in_bits_ctrl_vpu_vlmul[1:0]) + 2'h1)}
       : _eNumMax1H_T_8[6:0]};
  wire [10:0]  eStart =
    11'({4'h0, io_in_bits_ctrl_vpu_vuopIdx}
        * {7'h0,
           |_eNum1H_orMatrixOutputs_T_4,
           |_eNum1H_orMatrixOutputs_T_2,
           |_eNum1H_orMatrixOutputs_T,
           1'h0});
  wire [127:0] maskPart =
    (io_in_bits_ctrl_vpu_vm
       ? 128'hFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
       : io_in_bits_data_src_3) >> eStart;
  wire [7:0]   mask =
    {4'h0,
     {2'h0, (|_eNum1H_orMatrixOutputs_T) ? maskPart[1:0] : 2'h0}
       | ((|_eNum1H_orMatrixOutputs_T_2) ? maskPart[3:0] : 4'h0)}
    | ((|_eNum1H_orMatrixOutputs_T_4) ? maskPart[7:0] : 8'h0);
  wire [10:0]  _GEN_0 =
    {3'h0, io_in_bits_data_src_4 > _GEN ? _GEN : io_in_bits_data_src_4};
  always @(posedge clock) begin
    if (io_in_valid) begin
      outEew_r <=
        {|_output1H_orMatrixOutputs_T_3, |_output1H_orMatrixOutputs_T_1}
        | {2{|_output1H_orMatrixOutputs_T_5}};
      fflagsEnCycle2_r_0 <= mask[0] & _GEN_0 > eStart;
      fflagsEnCycle2_r_1 <= mask[1] & _GEN_0 > 11'(eStart + 11'h1);
      fflagsEnCycle2_r_2 <= mask[2] & _GEN_0 > 11'(eStart + 11'h2);
      fflagsEnCycle2_r_3 <= mask[3] & _GEN_0 > 11'(eStart + 11'h3);
      fflagsEnCycle2_r_4 <= mask[4] & _GEN_0 > 11'(eStart + 11'h4);
      fflagsEnCycle2_r_5 <= mask[5] & _GEN_0 > 11'(eStart + 11'h5);
      fflagsEnCycle2_r_6 <= mask[6] & _GEN_0 > 11'(eStart + 11'h6);
      fflagsEnCycle2_r_7 <= mask[7] & _GEN_0 > 11'(eStart + 11'h7);
      narrow_r <= isNarrowCvt;
    end
    if (fireReg_last_r) begin
      outEew <= outEew_r;
      fflagsEnCycle2_0 <= fflagsEnCycle2_r_0;
      fflagsEnCycle2_1 <= fflagsEnCycle2_r_1;
      fflagsEnCycle2_2 <= fflagsEnCycle2_r_2;
      fflagsEnCycle2_3 <= fflagsEnCycle2_r_3;
      fflagsEnCycle2_4 <= fflagsEnCycle2_r_4;
      fflagsEnCycle2_5 <= fflagsEnCycle2_r_5;
      fflagsEnCycle2_6 <= fflagsEnCycle2_r_6;
      fflagsEnCycle2_7 <= fflagsEnCycle2_r_7;
      narrow <= narrow_r;
    end
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:91];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [6:0] i = 7'h0; i < 7'h5C; i += 7'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        validVecThisFu_1 = _RANDOM[7'h0][0];
        validVecThisFu_2 = _RANDOM[7'h0][1];
        fireReg_last_r = _RANDOM[7'h5B][6];
        outEew_r = _RANDOM[7'h5B][10:9];
        outEew = _RANDOM[7'h5B][12:11];
        fflagsEnCycle2_r_0 = _RANDOM[7'h5B][13];
        fflagsEnCycle2_r_1 = _RANDOM[7'h5B][14];
        fflagsEnCycle2_r_2 = _RANDOM[7'h5B][15];
        fflagsEnCycle2_r_3 = _RANDOM[7'h5B][16];
        fflagsEnCycle2_r_4 = _RANDOM[7'h5B][17];
        fflagsEnCycle2_r_5 = _RANDOM[7'h5B][18];
        fflagsEnCycle2_r_6 = _RANDOM[7'h5B][19];
        fflagsEnCycle2_r_7 = _RANDOM[7'h5B][20];
        fflagsEnCycle2_0 = _RANDOM[7'h5B][21];
        fflagsEnCycle2_1 = _RANDOM[7'h5B][22];
        fflagsEnCycle2_2 = _RANDOM[7'h5B][23];
        fflagsEnCycle2_3 = _RANDOM[7'h5B][24];
        fflagsEnCycle2_4 = _RANDOM[7'h5B][25];
        fflagsEnCycle2_5 = _RANDOM[7'h5B][26];
        fflagsEnCycle2_6 = _RANDOM[7'h5B][27];
        fflagsEnCycle2_7 = _RANDOM[7'h5B][28];
        narrow_r = _RANDOM[7'h5B][29];
        narrow = _RANDOM[7'h5B][30];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        validVecThisFu_1 = 1'h0;
        validVecThisFu_2 = 1'h0;
        fireReg_last_r = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  VectorCvtTop vfcvt (
    .clock            (clock),
    .reset            (reset),
    .io_fire          (io_in_valid),
    .io_uopIdx        (io_in_bits_ctrl_vpu_vuopIdx[0]),
    .io_src_0         (io_in_bits_data_src_1[63:0]),
    .io_src_1         (io_in_bits_data_src_1[127:64]),
    .io_opType        (io_in_bits_ctrl_fuOpType[7:0]),
    .io_sew           (io_in_bits_ctrl_vpu_vsew),
    .io_rm
      ({2'h0, isRtz} | (isRod ? 3'h6 : 3'h0) | (isRtz | isRod ? 3'h0 : io_frm)),
    .io_outputWidth1H
      ({|_output1H_orMatrixOutputs_T_5,
        |_output1H_orMatrixOutputs_T_3,
        |_output1H_orMatrixOutputs_T_1,
        &{output1H_invInputs[0],
          output1H_invInputs[1],
          output1H_invInputs[2],
          io_in_bits_ctrl_fuOpType[4]}}),
    .io_isWiden       (isWidenCvt),
    .io_isNarrow      (isNarrowCvt),
    .io_result        (_vfcvt_io_result),
    .io_fflags        (_vfcvt_io_fflags)
  );
  Mgu mgu (
    .io_in_vd
      (narrow
         ? (io_in_bits_ctrlPipe_2_vpu_vuopIdx[0] & narrow
              ? {_vfcvt_io_result[63:0], io_in_bits_dataPipe_2_src_2[63:0]}
              : {io_in_bits_dataPipe_2_src_2[127:64], _vfcvt_io_result[63:0]})
         : _vfcvt_io_result),
    .io_in_oldVd        (io_in_bits_dataPipe_2_src_2),
    .io_in_mask
      (io_in_bits_ctrlPipe_2_vpu_vm
         ? 128'hFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
         : io_in_bits_dataPipe_2_src_3),
    .io_in_info_ta      (io_in_bits_ctrlPipe_2_vpu_vta),
    .io_in_info_ma      (io_in_bits_ctrlPipe_2_vpu_vma),
    .io_in_info_vl      (io_in_bits_dataPipe_2_src_4),
    .io_in_info_vstart  (io_in_bits_ctrlPipe_2_vpu_vstart),
    .io_in_info_eew     (outEew),
    .io_in_info_vdIdx   (io_in_bits_ctrlPipe_2_vpu_vuopIdx[2:0]),
    .io_in_info_narrow  (narrow),
    .io_in_info_dstMask (io_in_bits_ctrlPipe_2_vpu_isDstMask),
    .io_out_vd          (io_out_bits_res_data),
    .io_out_active      (/* unused */)
  );
  assign io_out_valid = io_in_bits_validPipe_2 & validVecThisFu_2;
  assign io_out_bits_ctrl_robIdx_flag = io_in_bits_ctrlPipe_2_robIdx_flag;
  assign io_out_bits_ctrl_robIdx_value = io_in_bits_ctrlPipe_2_robIdx_value;
  assign io_out_bits_ctrl_pdest = io_in_bits_ctrlPipe_2_pdest;
  assign io_out_bits_ctrl_vecWen = io_in_bits_ctrlPipe_2_vecWen;
  assign io_out_bits_ctrl_v0Wen = io_in_bits_ctrlPipe_2_v0Wen;
  assign io_out_bits_ctrl_fpu_wflags = io_in_bits_ctrlPipe_2_fpu_wflags;
  assign io_out_bits_res_fflags =
    (fflagsEnCycle2_0 ? _vfcvt_io_fflags[4:0] : 5'h0)
    | (fflagsEnCycle2_1 ? _vfcvt_io_fflags[9:5] : 5'h0)
    | (fflagsEnCycle2_2 ? _vfcvt_io_fflags[14:10] : 5'h0)
    | (fflagsEnCycle2_3 ? _vfcvt_io_fflags[19:15] : 5'h0)
    | (fflagsEnCycle2_4 ? _vfcvt_io_fflags[24:20] : 5'h0)
    | (fflagsEnCycle2_5 ? _vfcvt_io_fflags[29:25] : 5'h0)
    | (fflagsEnCycle2_6 ? _vfcvt_io_fflags[34:30] : 5'h0)
    | (fflagsEnCycle2_7 ? _vfcvt_io_fflags[39:35] : 5'h0);
endmodule

