// Generated by CIRCT firtool-1.62.1
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

module BusErrorUnit(
  input         clock,
  input         reset,
  output        auto_in_a_ready,
  input         auto_in_a_valid,
  input  [3:0]  auto_in_a_bits_opcode,
  input  [1:0]  auto_in_a_bits_size,
  input  [2:0]  auto_in_a_bits_source,
  input  [29:0] auto_in_a_bits_address,
  input  [7:0]  auto_in_a_bits_mask,
  input  [63:0] auto_in_a_bits_data,
  input         auto_in_d_ready,
  output        auto_in_d_valid,
  output [3:0]  auto_in_d_bits_opcode,
  output [1:0]  auto_in_d_bits_size,
  output [2:0]  auto_in_d_bits_source,
  output [63:0] auto_in_d_bits_data,
  output        auto_int_out_0,
  input         io_errors_icache_ecc_error_valid,
  input  [47:0] io_errors_icache_ecc_error_bits,
  input         io_errors_dcache_ecc_error_valid,
  input  [47:0] io_errors_dcache_ecc_error_bits,
  input         io_errors_l2_ecc_error_valid,
  input  [47:0] io_errors_l2_ecc_error_bits
);

  wire             out_woready_9;
  reg  [1:0]       cause_reg;
  reg  [47:0]      pad_1;
  reg              enable_0;
  reg              enable_1;
  reg              enable_2;
  reg              global_interrupt_0;
  reg              global_interrupt_1;
  reg              global_interrupt_2;
  reg              accrued_0;
  reg              accrued_1;
  reg              accrued_2;
  reg              local_interrupt_0;
  reg              local_interrupt_1;
  reg              local_interrupt_2;
  wire             _GEN = io_errors_icache_ecc_error_valid & enable_0;
  wire             _GEN_0 = io_errors_dcache_ecc_error_valid & enable_1;
  wire             _GEN_1 = io_errors_l2_ecc_error_valid & enable_2;
  wire             _GEN_2 =
    cause_reg == 2'h0
    & (io_errors_l2_ecc_error_valid ? enable_2 | _GEN_0 | _GEN : _GEN_0 | _GEN);
  wire             in_bits_read = auto_in_a_bits_opcode == 4'h4;
  wire             _out_T_11 = auto_in_a_bits_address[11:6] == 6'h0;
  wire             valids_1_0 = out_woready_9 & auto_in_a_bits_mask[0];
  wire             valids_1_1 = out_woready_9 & auto_in_a_bits_mask[1];
  wire             valids_1_2 = out_woready_9 & auto_in_a_bits_mask[2];
  wire             valids_1_3 = out_woready_9 & auto_in_a_bits_mask[3];
  wire             valids_1_4 = out_woready_9 & auto_in_a_bits_mask[4];
  wire             valids_1_5 = out_woready_9 & auto_in_a_bits_mask[5];
  wire             _out_wofireMux_T_2 = auto_in_a_valid & auto_in_d_ready & ~in_bits_read;
  assign out_woready_9 =
    _out_wofireMux_T_2 & auto_in_a_bits_address[5:3] == 3'h1 & _out_T_11;
  wire             out_woready_13 =
    _out_wofireMux_T_2 & auto_in_a_bits_address[5:3] == 3'h2 & _out_T_11;
  wire             out_woready_16 =
    _out_wofireMux_T_2 & auto_in_a_bits_address[5:3] == 3'h3 & _out_T_11;
  wire             out_woready_19 =
    _out_wofireMux_T_2 & auto_in_a_bits_address[5:3] == 3'h4 & _out_T_11;
  wire             out_woready_4 =
    _out_wofireMux_T_2 & auto_in_a_bits_address[5:3] == 3'h5 & _out_T_11;
  wire [7:0]       _GEN_3 =
    {{1'h1},
     {1'h1},
     {_out_T_11},
     {_out_T_11},
     {_out_T_11},
     {_out_T_11},
     {_out_T_11},
     {_out_T_11}};
  wire [7:0][47:0] _GEN_4 =
    {{48'h0},
     {48'h0},
     {{45'h0, local_interrupt_2, local_interrupt_1, local_interrupt_0}},
     {{45'h0, accrued_2, accrued_1, accrued_0}},
     {{45'h0, global_interrupt_2, global_interrupt_1, global_interrupt_0}},
     {{45'h0, enable_2, enable_1, enable_0}},
     {pad_1},
     {{46'h0, cause_reg}}};
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      cause_reg <= 2'h0;
      enable_0 <= 1'h1;
      enable_1 <= 1'h1;
      enable_2 <= 1'h1;
      global_interrupt_0 <= 1'h0;
      global_interrupt_1 <= 1'h0;
      global_interrupt_2 <= 1'h0;
      accrued_0 <= 1'h0;
      accrued_1 <= 1'h0;
      accrued_2 <= 1'h0;
      local_interrupt_0 <= 1'h0;
      local_interrupt_1 <= 1'h0;
      local_interrupt_2 <= 1'h0;
    end
    else begin
      if (_out_wofireMux_T_2 & auto_in_a_bits_address[5:3] == 3'h0 & _out_T_11
          & auto_in_a_bits_mask[0])
        cause_reg <= auto_in_a_bits_data[1:0];
      else if (_GEN_2)
        cause_reg <= _GEN_1 ? 2'h2 : {1'h0, _GEN_0};
      if (out_woready_13 & auto_in_a_bits_mask[0])
        enable_0 <= auto_in_a_bits_data[0];
      if (out_woready_13 & auto_in_a_bits_mask[0])
        enable_1 <= auto_in_a_bits_data[1];
      if (out_woready_13 & auto_in_a_bits_mask[0])
        enable_2 <= auto_in_a_bits_data[2];
      if (out_woready_16 & auto_in_a_bits_mask[0])
        global_interrupt_0 <= auto_in_a_bits_data[0];
      if (out_woready_16 & auto_in_a_bits_mask[0])
        global_interrupt_1 <= auto_in_a_bits_data[1];
      if (out_woready_16 & auto_in_a_bits_mask[0])
        global_interrupt_2 <= auto_in_a_bits_data[2];
      if (out_woready_19 & auto_in_a_bits_mask[0])
        accrued_0 <= auto_in_a_bits_data[0];
      else
        accrued_0 <= io_errors_icache_ecc_error_valid | accrued_0;
      if (out_woready_19 & auto_in_a_bits_mask[0])
        accrued_1 <= auto_in_a_bits_data[1];
      else
        accrued_1 <= io_errors_dcache_ecc_error_valid | accrued_1;
      if (out_woready_19 & auto_in_a_bits_mask[0])
        accrued_2 <= auto_in_a_bits_data[2];
      else
        accrued_2 <= io_errors_l2_ecc_error_valid | accrued_2;
      if (out_woready_4 & auto_in_a_bits_mask[0])
        local_interrupt_0 <= auto_in_a_bits_data[0];
      if (out_woready_4 & auto_in_a_bits_mask[0])
        local_interrupt_1 <= auto_in_a_bits_data[1];
      if (out_woready_4 & auto_in_a_bits_mask[0])
        local_interrupt_2 <= auto_in_a_bits_data[2];
    end
  end // always @(posedge, posedge)
  always @(posedge clock) begin
    if (valids_1_0 | valids_1_1 | valids_1_2 | valids_1_3 | valids_1_4 | valids_1_5)
      pad_1 <=
        {valids_1_5 ? auto_in_a_bits_data[47:40] : pad_1[47:40],
         valids_1_4 ? auto_in_a_bits_data[39:32] : pad_1[39:32],
         valids_1_3 ? auto_in_a_bits_data[31:24] : pad_1[31:24],
         valids_1_2 ? auto_in_a_bits_data[23:16] : pad_1[23:16],
         valids_1_1 ? auto_in_a_bits_data[15:8] : pad_1[15:8],
         valids_1_0 ? auto_in_a_bits_data[7:0] : pad_1[7:0]};
    else if (_GEN_2)
      pad_1 <=
        _GEN_1
          ? io_errors_l2_ecc_error_bits
          : _GEN_0 ? io_errors_dcache_ecc_error_bits : io_errors_icache_ecc_error_bits;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:1];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [1:0] i = 2'h0; i < 2'h2; i += 2'h1) begin
          _RANDOM[i[0]] = `RANDOM;
        end
        cause_reg = _RANDOM[1'h0][1:0];
        pad_1 = {_RANDOM[1'h0][31:2], _RANDOM[1'h1][17:0]};
        enable_0 = _RANDOM[1'h1][18];
        enable_1 = _RANDOM[1'h1][19];
        enable_2 = _RANDOM[1'h1][20];
        global_interrupt_0 = _RANDOM[1'h1][21];
        global_interrupt_1 = _RANDOM[1'h1][22];
        global_interrupt_2 = _RANDOM[1'h1][23];
        accrued_0 = _RANDOM[1'h1][24];
        accrued_1 = _RANDOM[1'h1][25];
        accrued_2 = _RANDOM[1'h1][26];
        local_interrupt_0 = _RANDOM[1'h1][27];
        local_interrupt_1 = _RANDOM[1'h1][28];
        local_interrupt_2 = _RANDOM[1'h1][29];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        cause_reg = 2'h0;
        enable_0 = 1'h1;
        enable_1 = 1'h1;
        enable_2 = 1'h1;
        global_interrupt_0 = 1'h0;
        global_interrupt_1 = 1'h0;
        global_interrupt_2 = 1'h0;
        accrued_0 = 1'h0;
        accrued_1 = 1'h0;
        accrued_2 = 1'h0;
        local_interrupt_0 = 1'h0;
        local_interrupt_1 = 1'h0;
        local_interrupt_2 = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign auto_in_a_ready = auto_in_d_ready;
  assign auto_in_d_valid = auto_in_a_valid;
  assign auto_in_d_bits_opcode = {3'h0, in_bits_read};
  assign auto_in_d_bits_size = auto_in_a_bits_size;
  assign auto_in_d_bits_source = auto_in_a_bits_source;
  assign auto_in_d_bits_data =
    {16'h0,
     _GEN_3[auto_in_a_bits_address[5:3]] ? _GEN_4[auto_in_a_bits_address[5:3]] : 48'h0};
  assign auto_int_out_0 =
    |({accrued_2, accrued_1, accrued_0}
      & {global_interrupt_2, global_interrupt_1, global_interrupt_0});
endmodule

