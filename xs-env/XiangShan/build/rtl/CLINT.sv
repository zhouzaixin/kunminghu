// Generated by CIRCT firtool-1.62.1
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

module CLINT(
  input         clock,
  input         reset,
  output        auto_int_out_0,
  output        auto_int_out_1,
  output        auto_in_a_ready,
  input         auto_in_a_valid,
  input  [3:0]  auto_in_a_bits_opcode,
  input  [1:0]  auto_in_a_bits_size,
  input  [2:0]  auto_in_a_bits_source,
  input  [29:0] auto_in_a_bits_address,
  input  [7:0]  auto_in_a_bits_mask,
  input  [63:0] auto_in_a_bits_data,
  input         auto_in_d_ready,
  output        auto_in_d_valid,
  output [3:0]  auto_in_d_bits_opcode,
  output [1:0]  auto_in_d_bits_size,
  output [2:0]  auto_in_d_bits_source,
  output [63:0] auto_in_d_bits_data,
  input         io_rtcTick,
  output        io_time_valid,
  output [63:0] io_time_bits
);

  wire             out_woready_9;
  wire             out_woready_17;
  reg  [63:0]      time_0;
  reg  [63:0]      pad;
  reg              ipi_0;
  reg              io_time_valid_REG;
  wire             in_bits_read = auto_in_a_bits_opcode == 4'h4;
  wire             _out_T_5 = auto_in_a_bits_address[13:3] == 11'h0;
  wire             valids_1_0 = out_woready_9 & auto_in_a_bits_mask[0];
  wire             valids_1_1 = out_woready_9 & auto_in_a_bits_mask[1];
  wire             valids_1_2 = out_woready_9 & auto_in_a_bits_mask[2];
  wire             valids_1_3 = out_woready_9 & auto_in_a_bits_mask[3];
  wire             valids_1_4 = out_woready_9 & auto_in_a_bits_mask[4];
  wire             valids_1_5 = out_woready_9 & auto_in_a_bits_mask[5];
  wire             valids_1_6 = out_woready_9 & auto_in_a_bits_mask[6];
  wire             valids_1_7 = out_woready_9 & auto_in_a_bits_mask[7];
  wire             valids_0 = out_woready_17 & auto_in_a_bits_mask[0];
  wire             valids_1 = out_woready_17 & auto_in_a_bits_mask[1];
  wire             valids_2 = out_woready_17 & auto_in_a_bits_mask[2];
  wire             valids_3 = out_woready_17 & auto_in_a_bits_mask[3];
  wire             valids_4 = out_woready_17 & auto_in_a_bits_mask[4];
  wire             valids_5 = out_woready_17 & auto_in_a_bits_mask[5];
  wire             valids_6 = out_woready_17 & auto_in_a_bits_mask[6];
  wire             valids_7 = out_woready_17 & auto_in_a_bits_mask[7];
  wire             _out_wofireMux_T_2 = auto_in_a_valid & auto_in_d_ready & ~in_bits_read;
  assign out_woready_17 =
    _out_wofireMux_T_2 & auto_in_a_bits_address[15:14] == 2'h1 & _out_T_5;
  assign out_woready_9 =
    _out_wofireMux_T_2 & auto_in_a_bits_address[15:14] == 2'h2
    & (&(auto_in_a_bits_address[13:3]));
  wire [3:0]       _GEN =
    {{1'h1}, {&(auto_in_a_bits_address[13:3])}, {_out_T_5}, {_out_T_5}};
  wire [3:0][63:0] _GEN_0 = {{64'h0}, {time_0}, {pad}, {{63'h0, ipi_0}}};
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      time_0 <= 64'h0;
      ipi_0 <= 1'h0;
    end
    else begin
      if (valids_1_0 | valids_1_1 | valids_1_2 | valids_1_3 | valids_1_4 | valids_1_5
          | valids_1_6 | valids_1_7)
        time_0 <=
          {valids_1_7 ? auto_in_a_bits_data[63:56] : time_0[63:56],
           valids_1_6 ? auto_in_a_bits_data[55:48] : time_0[55:48],
           valids_1_5 ? auto_in_a_bits_data[47:40] : time_0[47:40],
           valids_1_4 ? auto_in_a_bits_data[39:32] : time_0[39:32],
           valids_1_3 ? auto_in_a_bits_data[31:24] : time_0[31:24],
           valids_1_2 ? auto_in_a_bits_data[23:16] : time_0[23:16],
           valids_1_1 ? auto_in_a_bits_data[15:8] : time_0[15:8],
           valids_1_0 ? auto_in_a_bits_data[7:0] : time_0[7:0]};
      else if (io_rtcTick)
        time_0 <= 64'(time_0 + 64'h1);
      if (_out_wofireMux_T_2 & auto_in_a_bits_address[15:14] == 2'h0 & _out_T_5
          & auto_in_a_bits_mask[0])
        ipi_0 <= auto_in_a_bits_data[0];
    end
  end // always @(posedge, posedge)
  always @(posedge clock) begin
    if (valids_0 | valids_1 | valids_2 | valids_3 | valids_4 | valids_5 | valids_6
        | valids_7)
      pad <=
        {valids_7 ? auto_in_a_bits_data[63:56] : pad[63:56],
         valids_6 ? auto_in_a_bits_data[55:48] : pad[55:48],
         valids_5 ? auto_in_a_bits_data[47:40] : pad[47:40],
         valids_4 ? auto_in_a_bits_data[39:32] : pad[39:32],
         valids_3 ? auto_in_a_bits_data[31:24] : pad[31:24],
         valids_2 ? auto_in_a_bits_data[23:16] : pad[23:16],
         valids_1 ? auto_in_a_bits_data[15:8] : pad[15:8],
         valids_0 ? auto_in_a_bits_data[7:0] : pad[7:0]};
    io_time_valid_REG <= io_rtcTick;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:4];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [2:0] i = 3'h0; i < 3'h5; i += 3'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        time_0 = {_RANDOM[3'h0], _RANDOM[3'h1]};
        pad = {_RANDOM[3'h2], _RANDOM[3'h3]};
        ipi_0 = _RANDOM[3'h4][0];
        io_time_valid_REG = _RANDOM[3'h4][1];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        time_0 = 64'h0;
        ipi_0 = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign auto_int_out_0 = ipi_0;
  assign auto_int_out_1 = time_0 >= pad;
  assign auto_in_a_ready = auto_in_d_ready;
  assign auto_in_d_valid = auto_in_a_valid;
  assign auto_in_d_bits_opcode = {3'h0, in_bits_read};
  assign auto_in_d_bits_size = auto_in_a_bits_size;
  assign auto_in_d_bits_source = auto_in_a_bits_source;
  assign auto_in_d_bits_data =
    _GEN[auto_in_a_bits_address[15:14]] ? _GEN_0[auto_in_a_bits_address[15:14]] : 64'h0;
  assign io_time_valid = io_time_valid_REG;
  assign io_time_bits = time_0;
endmodule

