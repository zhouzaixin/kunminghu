// Generated by CIRCT firtool-1.62.1
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

module TLFIFOFixer(
  input          clock,
  input          reset,
  output         auto_in_a_ready,
  input          auto_in_a_valid,
  input  [3:0]   auto_in_a_bits_opcode,
  input  [2:0]   auto_in_a_bits_size,
  input  [1:0]   auto_in_a_bits_source,
  input  [47:0]  auto_in_a_bits_address,
  input  [31:0]  auto_in_a_bits_mask,
  input  [255:0] auto_in_a_bits_data,
  input          auto_in_d_ready,
  output         auto_in_d_valid,
  output [3:0]   auto_in_d_bits_opcode,
  output [2:0]   auto_in_d_bits_size,
  output [1:0]   auto_in_d_bits_source,
  output         auto_in_d_bits_denied,
  output [255:0] auto_in_d_bits_data,
  output         auto_in_d_bits_corrupt,
  input          auto_out_a_ready,
  output         auto_out_a_valid,
  output [3:0]   auto_out_a_bits_opcode,
  output [2:0]   auto_out_a_bits_size,
  output [1:0]   auto_out_a_bits_source,
  output [47:0]  auto_out_a_bits_address,
  output [31:0]  auto_out_a_bits_mask,
  output [255:0] auto_out_a_bits_data,
  output         auto_out_d_ready,
  input          auto_out_d_valid,
  input  [3:0]   auto_out_d_bits_opcode,
  input  [2:0]   auto_out_d_bits_size,
  input  [1:0]   auto_out_d_bits_source,
  input          auto_out_d_bits_denied,
  input  [255:0] auto_out_d_bits_data,
  input          auto_out_d_bits_corrupt
);

  wire        nodeIn_a_ready;
  wire        a_id = auto_in_a_bits_address[47:31] == 17'h0;
  wire        _stalls_id_T_4 = nodeIn_a_ready & auto_in_a_valid;
  reg         a_first_counter;
  reg         d_first_counter;
  reg         flight_0;
  reg         flight_1;
  reg         flight_2;
  reg         flight_3;
  reg         stalls_id;
  reg         stalls_id_1;
  wire        stall =
    ~(auto_in_a_bits_source[1]) & ~a_first_counter & (flight_0 | flight_1)
    & (~a_id | stalls_id != a_id) | auto_in_a_bits_source[1] & ~a_first_counter
    & (flight_2 | flight_3) & (~a_id | stalls_id_1 != a_id);
  assign nodeIn_a_ready = auto_out_a_ready & ~stall;
  wire [12:0] _a_first_beats1_decode_T = 13'h3F << auto_in_a_bits_size;
  wire [12:0] _d_first_beats1_decode_T = 13'h3F << auto_out_d_bits_size;
  wire        _GEN = ~a_first_counter & _stalls_id_T_4;
  wire        _GEN_0 =
    ~d_first_counter & auto_out_d_bits_opcode != 4'h6 & auto_in_d_ready
    & auto_out_d_valid;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      a_first_counter <= 1'h0;
      d_first_counter <= 1'h0;
      flight_0 <= 1'h0;
      flight_1 <= 1'h0;
      flight_2 <= 1'h0;
      flight_3 <= 1'h0;
    end
    else begin
      if (_stalls_id_T_4) begin
        if (a_first_counter)
          a_first_counter <= 1'(a_first_counter - 1'h1);
        else
          a_first_counter <= ~(auto_in_a_bits_opcode[2]) & ~(_a_first_beats1_decode_T[5]);
      end
      if (auto_in_d_ready & auto_out_d_valid) begin
        if (d_first_counter)
          d_first_counter <= 1'(d_first_counter - 1'h1);
        else
          d_first_counter <= auto_out_d_bits_opcode[0] & ~(_d_first_beats1_decode_T[5]);
      end
      flight_0 <=
        ~(_GEN_0 & auto_out_d_bits_source == 2'h0)
        & (_GEN & auto_in_a_bits_source == 2'h0 | flight_0);
      flight_1 <=
        ~(_GEN_0 & auto_out_d_bits_source == 2'h1)
        & (_GEN & auto_in_a_bits_source == 2'h1 | flight_1);
      flight_2 <=
        ~(_GEN_0 & auto_out_d_bits_source == 2'h2)
        & (_GEN & auto_in_a_bits_source == 2'h2 | flight_2);
      flight_3 <=
        ~(_GEN_0 & (&auto_out_d_bits_source))
        & (_GEN & (&auto_in_a_bits_source) | flight_3);
    end
  end // always @(posedge, posedge)
  always @(posedge clock) begin
    if (_stalls_id_T_4 & ~(auto_in_a_bits_source[1]))
      stalls_id <= a_id;
    if (_stalls_id_T_4 & auto_in_a_bits_source[1])
      stalls_id_1 <= a_id;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        a_first_counter = _RANDOM[/*Zero width*/ 1'b0][0];
        d_first_counter = _RANDOM[/*Zero width*/ 1'b0][1];
        flight_0 = _RANDOM[/*Zero width*/ 1'b0][2];
        flight_1 = _RANDOM[/*Zero width*/ 1'b0][3];
        flight_2 = _RANDOM[/*Zero width*/ 1'b0][4];
        flight_3 = _RANDOM[/*Zero width*/ 1'b0][5];
        stalls_id = _RANDOM[/*Zero width*/ 1'b0][6];
        stalls_id_1 = _RANDOM[/*Zero width*/ 1'b0][7];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        a_first_counter = 1'h0;
        d_first_counter = 1'h0;
        flight_0 = 1'h0;
        flight_1 = 1'h0;
        flight_2 = 1'h0;
        flight_3 = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign auto_in_a_ready = nodeIn_a_ready;
  assign auto_in_d_valid = auto_out_d_valid;
  assign auto_in_d_bits_opcode = auto_out_d_bits_opcode;
  assign auto_in_d_bits_size = auto_out_d_bits_size;
  assign auto_in_d_bits_source = auto_out_d_bits_source;
  assign auto_in_d_bits_denied = auto_out_d_bits_denied;
  assign auto_in_d_bits_data = auto_out_d_bits_data;
  assign auto_in_d_bits_corrupt = auto_out_d_bits_corrupt;
  assign auto_out_a_valid = auto_in_a_valid & ~stall;
  assign auto_out_a_bits_opcode = auto_in_a_bits_opcode;
  assign auto_out_a_bits_size = auto_in_a_bits_size;
  assign auto_out_a_bits_source = auto_in_a_bits_source;
  assign auto_out_a_bits_address = auto_in_a_bits_address;
  assign auto_out_a_bits_mask = auto_in_a_bits_mask;
  assign auto_out_a_bits_data = auto_in_a_bits_data;
  assign auto_out_d_ready = auto_in_d_ready;
endmodule

