// Generated by CIRCT firtool-1.62.1
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

module SourceA(
  input          clock,
  input          reset,
  input          io_a_ready,
  output         io_a_valid,
  output [3:0]   io_a_bits_opcode,
  output [2:0]   io_a_bits_param,
  output [2:0]   io_a_bits_size,
  output [3:0]   io_a_bits_source,
  output [47:0]  io_a_bits_address,
  output [31:0]  io_a_bits_mask,
  output [255:0] io_a_bits_data,
  output         io_task_ready,
  input          io_task_valid,
  input  [30:0]  io_task_bits_tag,
  input  [10:0]  io_task_bits_set,
  input  [5:0]   io_task_bits_off,
  input  [2:0]   io_task_bits_opcode,
  input  [2:0]   io_task_bits_param,
  input  [3:0]   io_task_bits_source,
  input  [3:0]   io_task_bits_bufIdx,
  input  [2:0]   io_task_bits_size,
  input          io_task_bits_putData,
  input          io_pb_pop_ready,
  output         io_pb_pop_valid,
  output [3:0]   io_pb_pop_bits_bufIdx,
  output         io_pb_pop_bits_count,
  output         io_pb_pop_bits_last,
  input  [255:0] io_pb_beat_data,
  input  [31:0]  io_pb_beat_mask
);

  wire         allowed_1;
  wire         allowed_0;
  wire         s1_ready;
  wire         io_pb_pop_valid_0;
  reg          busy;
  wire         io_task_ready_0 = io_a_ready & allowed_1 & ~busy;
  wire         _s0_task_T = io_task_ready_0 & io_task_valid;
  wire         a_acquire_valid = io_task_valid & ~io_task_bits_putData;
  reg          s1_full;
  reg  [30:0]  s0_task_tag;
  reg  [10:0]  s0_task_set;
  reg  [5:0]   s0_task_off;
  reg  [2:0]   s0_task_opcode;
  reg  [2:0]   s0_task_param;
  reg  [3:0]   s0_task_source;
  reg  [3:0]   s0_task_bufIdx;
  reg  [2:0]   s0_task_size;
  reg          s0_count;
  wire         s0_last = s0_count ^ s0_task_size != 3'h6;
  wire         s0_valid = io_pb_pop_ready & io_pb_pop_valid_0;
  assign io_pb_pop_valid_0 = busy & s1_ready;
  wire         s1_latch = s0_valid & s1_ready;
  reg  [30:0]  s1_task_tag;
  reg  [10:0]  s1_task_set;
  reg  [5:0]   s1_task_off;
  reg  [2:0]   s1_task_opcode;
  reg  [2:0]   s1_task_param;
  reg  [3:0]   s1_task_source;
  reg  [2:0]   s1_task_size;
  wire         s1_cango = s1_full & io_a_ready & allowed_0;
  reg          s1_pb_latch_REG;
  reg  [255:0] s1_pb_latch_r_data;
  reg  [31:0]  s1_pb_latch_r_mask;
  assign s1_ready = s1_cango | ~s1_full;
  reg          beatsLeft;
  wire         winner_1 = ~s1_full & a_acquire_valid;
  reg          state_0;
  reg          state_1;
  wire         muxState_0 = beatsLeft ? state_0 : s1_full;
  wire         muxState_1 = beatsLeft ? state_1 : winner_1;
  assign allowed_0 = ~beatsLeft | state_0;
  assign allowed_1 = beatsLeft ? state_1 : ~s1_full;
  wire         io_a_valid_0 =
    beatsLeft ? state_0 & s1_full | state_1 & a_acquire_valid : s1_full | a_acquire_valid;
  wire [12:0]  _decode_T = 13'h3F << s1_task_size;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      busy <= 1'h0;
      s1_full <= 1'h0;
      s0_count <= 1'h0;
      s1_pb_latch_r_data <= 256'h0;
      s1_pb_latch_r_mask <= 32'h0;
      beatsLeft <= 1'h0;
      state_0 <= 1'h0;
      state_1 <= 1'h0;
    end
    else begin
      busy <= ~(s0_valid & s0_last) & (_s0_task_T & io_task_bits_putData | busy);
      s1_full <= s1_latch | ~(s1_full & s1_cango) & s1_full;
      if (s0_valid)
        s0_count <= ~s0_last & 1'(s0_count - 1'h1);
      if (s1_pb_latch_REG) begin
        s1_pb_latch_r_data <= io_pb_beat_data;
        s1_pb_latch_r_mask <= io_pb_beat_mask;
      end
      if (~beatsLeft & io_a_ready)
        beatsLeft <=
          s1_full & ~(s1_task_opcode[2]) & ~(_decode_T[5]) | winner_1
          & ~(io_task_bits_opcode[2]);
      else
        beatsLeft <= 1'(beatsLeft - (io_a_ready & io_a_valid_0));
      if (beatsLeft) begin
      end
      else begin
        state_0 <= s1_full;
        state_1 <= winner_1;
      end
    end
  end // always @(posedge, posedge)
  always @(posedge clock) begin
    if (_s0_task_T & io_task_bits_putData) begin
      s0_task_tag <= io_task_bits_tag;
      s0_task_set <= io_task_bits_set;
      s0_task_off <= io_task_bits_off;
      s0_task_opcode <= io_task_bits_opcode;
      s0_task_param <= io_task_bits_param;
      s0_task_source <= io_task_bits_source;
      s0_task_bufIdx <= io_task_bits_bufIdx;
      s0_task_size <= io_task_bits_size;
    end
    if (s1_latch) begin
      s1_task_tag <= s0_task_tag;
      s1_task_set <= s0_task_set;
      s1_task_off <= s0_task_off;
      s1_task_opcode <= s0_task_opcode;
      s1_task_param <= s0_task_param;
      s1_task_source <= s0_task_source;
      s1_task_size <= s0_task_size;
    end
    s1_pb_latch_REG <= s1_latch;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:15];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [4:0] i = 5'h0; i < 5'h10; i += 5'h1) begin
          _RANDOM[i[3:0]] = `RANDOM;
        end
        busy = _RANDOM[4'h0][0];
        s1_full = _RANDOM[4'h0][1];
        s0_task_tag = {_RANDOM[4'h0][31:2], _RANDOM[4'h1][0]};
        s0_task_set = _RANDOM[4'h1][11:1];
        s0_task_off = _RANDOM[4'h1][17:12];
        s0_task_opcode = _RANDOM[4'h2][20:18];
        s0_task_param = _RANDOM[4'h2][23:21];
        s0_task_source = _RANDOM[4'h2][27:24];
        s0_task_bufIdx = _RANDOM[4'h2][31:28];
        s0_task_size = _RANDOM[4'h3][2:0];
        s0_count = _RANDOM[4'h3][9];
        s1_task_tag = {_RANDOM[4'h3][31:11], _RANDOM[4'h4][9:0]};
        s1_task_set = _RANDOM[4'h4][20:10];
        s1_task_off = _RANDOM[4'h4][26:21];
        s1_task_opcode = _RANDOM[4'h5][29:27];
        s1_task_param = {_RANDOM[4'h5][31:30], _RANDOM[4'h6][0]};
        s1_task_source = _RANDOM[4'h6][4:1];
        s1_task_size = _RANDOM[4'h6][11:9];
        s1_pb_latch_REG = _RANDOM[4'h6][18];
        s1_pb_latch_r_data =
          {_RANDOM[4'h6][31:19],
           _RANDOM[4'h7],
           _RANDOM[4'h8],
           _RANDOM[4'h9],
           _RANDOM[4'hA],
           _RANDOM[4'hB],
           _RANDOM[4'hC],
           _RANDOM[4'hD],
           _RANDOM[4'hE][18:0]};
        s1_pb_latch_r_mask = {_RANDOM[4'hE][31:19], _RANDOM[4'hF][18:0]};
        beatsLeft = _RANDOM[4'hF][20];
        state_0 = _RANDOM[4'hF][21];
        state_1 = _RANDOM[4'hF][22];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        busy = 1'h0;
        s1_full = 1'h0;
        s0_count = 1'h0;
        s1_pb_latch_r_data = 256'h0;
        s1_pb_latch_r_mask = 32'h0;
        beatsLeft = 1'h0;
        state_0 = 1'h0;
        state_1 = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_a_valid = io_a_valid_0;
  assign io_a_bits_opcode =
    (muxState_0 ? {1'h0, s1_task_opcode} : 4'h0)
    | (muxState_1 ? {1'h0, io_task_bits_opcode} : 4'h0);
  assign io_a_bits_param =
    (muxState_0 ? s1_task_param : 3'h0) | (muxState_1 ? io_task_bits_param : 3'h0);
  assign io_a_bits_size = (muxState_0 ? s1_task_size : 3'h0) | (muxState_1 ? 3'h6 : 3'h0);
  assign io_a_bits_source =
    (muxState_0 ? s1_task_source : 4'h0) | (muxState_1 ? io_task_bits_source : 4'h0);
  assign io_a_bits_address =
    (muxState_0 ? {s1_task_tag, s1_task_set, s1_task_off} : 48'h0)
    | (muxState_1 ? {io_task_bits_tag, io_task_bits_set, 6'h0} : 48'h0);
  assign io_a_bits_mask =
    (muxState_0 ? (s1_pb_latch_REG ? io_pb_beat_mask : s1_pb_latch_r_mask) : 32'h0)
    | {32{muxState_1}};
  assign io_a_bits_data =
    muxState_0 ? (s1_pb_latch_REG ? io_pb_beat_data : s1_pb_latch_r_data) : 256'h0;
  assign io_task_ready = io_task_ready_0;
  assign io_pb_pop_valid = io_pb_pop_valid_0;
  assign io_pb_pop_bits_bufIdx = s0_task_bufIdx;
  assign io_pb_pop_bits_count = s0_count;
  assign io_pb_pop_bits_last = s0_last;
endmodule

