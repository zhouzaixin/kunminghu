// Generated by CIRCT firtool-1.62.1
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

module skidBufferConnect(
  input          clock,
  input          reset,
  output         io_in_ready,
  input          io_in_valid,
  input  [15:0]  io_in_bits_flowMask,
  input  [127:0] io_in_bits_data,
  input  [63:0]  io_in_bits_baseAddr,
  input  [63:0]  io_in_bits_uopAddr,
  input  [127:0] io_in_bits_stride,
  input  [4:0]   io_in_bits_flowNum,
  input  [1:0]   io_in_bits_eew,
  input  [2:0]   io_in_bits_sew,
  input  [2:0]   io_in_bits_emul,
  input  [2:0]   io_in_bits_lmul,
  input  [2:0]   io_in_bits_instType,
  input  [4:0]   io_in_bits_indexedSplitOffset,
  input          io_in_bits_uop_ftqPtr_flag,
  input  [5:0]   io_in_bits_uop_ftqPtr_value,
  input  [3:0]   io_in_bits_uop_ftqOffset,
  input  [8:0]   io_in_bits_uop_fuOpType,
  input  [7:0]   io_in_bits_uop_vpu_vstart,
  input  [6:0]   io_in_bits_uop_vpu_vuopIdx,
  input  [1:0]   io_in_bits_uop_vpu_veew,
  input  [6:0]   io_in_bits_uop_uopIdx,
  input  [7:0]   io_in_bits_uop_pdest,
  input          io_in_bits_uop_robIdx_flag,
  input  [7:0]   io_in_bits_uop_robIdx_value,
  input          io_in_bits_uop_lqIdx_flag,
  input  [6:0]   io_in_bits_uop_lqIdx_value,
  input          io_in_bits_uop_sqIdx_flag,
  input  [5:0]   io_in_bits_uop_sqIdx_value,
  input          io_in_bits_preIsSplit,
  input  [3:0]   io_in_bits_mBIndex,
  input  [2:0]   io_in_bits_alignedType,
  input  [7:0]   io_in_bits_indexVlMaxInVd,
  input  [3:0]   io_in_bits_usLowBitsAddr,
  input          io_in_bits_usAligned128,
  input  [31:0]  io_in_bits_usMask,
  input          io_flush,
  input          io_out_ready,
  output         io_out_valid,
  output [15:0]  io_out_bits_flowMask,
  output [127:0] io_out_bits_data,
  output [63:0]  io_out_bits_baseAddr,
  output [63:0]  io_out_bits_uopAddr,
  output [127:0] io_out_bits_stride,
  output [4:0]   io_out_bits_flowNum,
  output [1:0]   io_out_bits_eew,
  output [2:0]   io_out_bits_sew,
  output [2:0]   io_out_bits_emul,
  output [2:0]   io_out_bits_lmul,
  output [2:0]   io_out_bits_instType,
  output [4:0]   io_out_bits_indexedSplitOffset,
  output         io_out_bits_uop_preDecodeInfo_isRVC,
  output         io_out_bits_uop_ftqPtr_flag,
  output [5:0]   io_out_bits_uop_ftqPtr_value,
  output [3:0]   io_out_bits_uop_ftqOffset,
  output [8:0]   io_out_bits_uop_fuOpType,
  output         io_out_bits_uop_rfWen,
  output         io_out_bits_uop_fpWen,
  output [7:0]   io_out_bits_uop_vpu_vstart,
  output [6:0]   io_out_bits_uop_vpu_vuopIdx,
  output [1:0]   io_out_bits_uop_vpu_veew,
  output [6:0]   io_out_bits_uop_uopIdx,
  output [7:0]   io_out_bits_uop_pdest,
  output         io_out_bits_uop_robIdx_flag,
  output [7:0]   io_out_bits_uop_robIdx_value,
  output         io_out_bits_uop_storeSetHit,
  output         io_out_bits_uop_waitForRobIdx_flag,
  output [7:0]   io_out_bits_uop_waitForRobIdx_value,
  output         io_out_bits_uop_loadWaitBit,
  output         io_out_bits_uop_loadWaitStrict,
  output         io_out_bits_uop_lqIdx_flag,
  output [6:0]   io_out_bits_uop_lqIdx_value,
  output         io_out_bits_uop_sqIdx_flag,
  output [5:0]   io_out_bits_uop_sqIdx_value,
  output         io_out_bits_preIsSplit,
  output [3:0]   io_out_bits_mBIndex,
  output [2:0]   io_out_bits_alignedType,
  output [7:0]   io_out_bits_indexVlMaxInVd,
  output [3:0]   io_out_bits_usLowBitsAddr,
  output         io_out_bits_usAligned128,
  output [31:0]  io_out_bits_usMask
);

  reg          state;
  wire         _stateNext_T_1 = ~state & io_in_valid;
  reg  [15:0]  dataBuffer_flowMask;
  reg  [127:0] dataBuffer_data;
  reg  [63:0]  dataBuffer_baseAddr;
  reg  [63:0]  dataBuffer_uopAddr;
  reg  [127:0] dataBuffer_stride;
  reg  [4:0]   dataBuffer_flowNum;
  reg  [1:0]   dataBuffer_eew;
  reg  [2:0]   dataBuffer_sew;
  reg  [2:0]   dataBuffer_emul;
  reg  [2:0]   dataBuffer_lmul;
  reg  [2:0]   dataBuffer_instType;
  reg  [4:0]   dataBuffer_indexedSplitOffset;
  reg          dataBuffer_uop_preDecodeInfo_isRVC;
  reg          dataBuffer_uop_ftqPtr_flag;
  reg  [5:0]   dataBuffer_uop_ftqPtr_value;
  reg  [3:0]   dataBuffer_uop_ftqOffset;
  reg  [8:0]   dataBuffer_uop_fuOpType;
  reg          dataBuffer_uop_rfWen;
  reg          dataBuffer_uop_fpWen;
  reg  [7:0]   dataBuffer_uop_vpu_vstart;
  reg  [6:0]   dataBuffer_uop_vpu_vuopIdx;
  reg  [1:0]   dataBuffer_uop_vpu_veew;
  reg  [6:0]   dataBuffer_uop_uopIdx;
  reg  [7:0]   dataBuffer_uop_pdest;
  reg          dataBuffer_uop_robIdx_flag;
  reg  [7:0]   dataBuffer_uop_robIdx_value;
  reg          dataBuffer_uop_storeSetHit;
  reg          dataBuffer_uop_waitForRobIdx_flag;
  reg  [7:0]   dataBuffer_uop_waitForRobIdx_value;
  reg          dataBuffer_uop_loadWaitBit;
  reg          dataBuffer_uop_loadWaitStrict;
  reg          dataBuffer_uop_lqIdx_flag;
  reg  [6:0]   dataBuffer_uop_lqIdx_value;
  reg          dataBuffer_uop_sqIdx_flag;
  reg  [5:0]   dataBuffer_uop_sqIdx_value;
  reg          dataBuffer_preIsSplit;
  reg  [3:0]   dataBuffer_mBIndex;
  reg  [2:0]   dataBuffer_alignedType;
  reg  [7:0]   dataBuffer_indexVlMaxInVd;
  reg  [3:0]   dataBuffer_usLowBitsAddr;
  reg          dataBuffer_usAligned128;
  reg  [31:0]  dataBuffer_usMask;
  always @(posedge clock or posedge reset) begin
    if (reset)
      state <= 1'h0;
    else if (state)
      state <= state & ~(io_out_ready | io_flush);
    else
      state <= ~io_out_ready & _stateNext_T_1 & ~io_flush;
  end // always @(posedge, posedge)
  wire         _dataBuffer_T_2 = ~io_out_ready & _stateNext_T_1;
  always @(posedge clock) begin
    if (_dataBuffer_T_2) begin
      dataBuffer_flowMask <= io_in_bits_flowMask;
      dataBuffer_data <= io_in_bits_data;
      dataBuffer_baseAddr <= io_in_bits_baseAddr;
      dataBuffer_uopAddr <= io_in_bits_uopAddr;
      dataBuffer_stride <= io_in_bits_stride;
      dataBuffer_flowNum <= io_in_bits_flowNum;
      dataBuffer_eew <= io_in_bits_eew;
      dataBuffer_sew <= io_in_bits_sew;
      dataBuffer_emul <= io_in_bits_emul;
      dataBuffer_lmul <= io_in_bits_lmul;
      dataBuffer_instType <= io_in_bits_instType;
      dataBuffer_indexedSplitOffset <= io_in_bits_indexedSplitOffset;
      dataBuffer_uop_ftqPtr_flag <= io_in_bits_uop_ftqPtr_flag;
      dataBuffer_uop_ftqPtr_value <= io_in_bits_uop_ftqPtr_value;
      dataBuffer_uop_ftqOffset <= io_in_bits_uop_ftqOffset;
      dataBuffer_uop_fuOpType <= io_in_bits_uop_fuOpType;
      dataBuffer_uop_vpu_vstart <= io_in_bits_uop_vpu_vstart;
      dataBuffer_uop_vpu_vuopIdx <= io_in_bits_uop_vpu_vuopIdx;
      dataBuffer_uop_vpu_veew <= io_in_bits_uop_vpu_veew;
      dataBuffer_uop_uopIdx <= io_in_bits_uop_uopIdx;
      dataBuffer_uop_pdest <= io_in_bits_uop_pdest;
      dataBuffer_uop_robIdx_flag <= io_in_bits_uop_robIdx_flag;
      dataBuffer_uop_robIdx_value <= io_in_bits_uop_robIdx_value;
      dataBuffer_uop_waitForRobIdx_value <= 8'h0;
      dataBuffer_uop_lqIdx_flag <= io_in_bits_uop_lqIdx_flag;
      dataBuffer_uop_lqIdx_value <= io_in_bits_uop_lqIdx_value;
      dataBuffer_uop_sqIdx_flag <= io_in_bits_uop_sqIdx_flag;
      dataBuffer_uop_sqIdx_value <= io_in_bits_uop_sqIdx_value;
      dataBuffer_preIsSplit <= io_in_bits_preIsSplit;
      dataBuffer_mBIndex <= io_in_bits_mBIndex;
      dataBuffer_alignedType <= io_in_bits_alignedType;
      dataBuffer_indexVlMaxInVd <= io_in_bits_indexVlMaxInVd;
      dataBuffer_usLowBitsAddr <= io_in_bits_usLowBitsAddr;
      dataBuffer_usAligned128 <= io_in_bits_usAligned128;
      dataBuffer_usMask <= io_in_bits_usMask;
    end
    dataBuffer_uop_preDecodeInfo_isRVC <=
      ~_dataBuffer_T_2 & dataBuffer_uop_preDecodeInfo_isRVC;
    dataBuffer_uop_rfWen <= ~_dataBuffer_T_2 & dataBuffer_uop_rfWen;
    dataBuffer_uop_fpWen <= ~_dataBuffer_T_2 & dataBuffer_uop_fpWen;
    dataBuffer_uop_storeSetHit <= ~_dataBuffer_T_2 & dataBuffer_uop_storeSetHit;
    dataBuffer_uop_waitForRobIdx_flag <=
      ~_dataBuffer_T_2 & dataBuffer_uop_waitForRobIdx_flag;
    dataBuffer_uop_loadWaitBit <= ~_dataBuffer_T_2 & dataBuffer_uop_loadWaitBit;
    dataBuffer_uop_loadWaitStrict <= ~_dataBuffer_T_2 & dataBuffer_uop_loadWaitStrict;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:59];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [5:0] i = 6'h0; i < 6'h3C; i += 6'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        state = _RANDOM[6'h0][0];
        dataBuffer_flowMask = _RANDOM[6'h0][16:1];
        dataBuffer_data =
          {_RANDOM[6'h1][31:1],
           _RANDOM[6'h2],
           _RANDOM[6'h3],
           _RANDOM[6'h4],
           _RANDOM[6'h5][0]};
        dataBuffer_baseAddr = {_RANDOM[6'h5][31:9], _RANDOM[6'h6], _RANDOM[6'h7][8:0]};
        dataBuffer_uopAddr = {_RANDOM[6'h7][31:9], _RANDOM[6'h8], _RANDOM[6'h9][8:0]};
        dataBuffer_stride =
          {_RANDOM[6'h9][31:9],
           _RANDOM[6'hA],
           _RANDOM[6'hB],
           _RANDOM[6'hC],
           _RANDOM[6'hD][8:0]};
        dataBuffer_flowNum = _RANDOM[6'hD][13:9];
        dataBuffer_eew = _RANDOM[6'hD][22:21];
        dataBuffer_sew = _RANDOM[6'hD][25:23];
        dataBuffer_emul = _RANDOM[6'hD][28:26];
        dataBuffer_lmul = _RANDOM[6'hD][31:29];
        dataBuffer_instType = _RANDOM[6'hE][10:8];
        dataBuffer_indexedSplitOffset = _RANDOM[6'hF][4:0];
        dataBuffer_uop_preDecodeInfo_isRVC = _RANDOM[6'h13][0];
        dataBuffer_uop_ftqPtr_flag = _RANDOM[6'h13][7];
        dataBuffer_uop_ftqPtr_value = _RANDOM[6'h13][13:8];
        dataBuffer_uop_ftqOffset = _RANDOM[6'h13][17:14];
        dataBuffer_uop_fuOpType = _RANDOM[6'h15][23:15];
        dataBuffer_uop_rfWen = _RANDOM[6'h15][24];
        dataBuffer_uop_fpWen = _RANDOM[6'h15][25];
        dataBuffer_uop_vpu_vstart = _RANDOM[6'h18][8:1];
        dataBuffer_uop_vpu_vuopIdx = _RANDOM[6'h18][27:21];
        dataBuffer_uop_vpu_veew = _RANDOM[6'h1D][9:8];
        dataBuffer_uop_uopIdx = _RANDOM[6'h1D][29:23];
        dataBuffer_uop_pdest = {_RANDOM[6'h20][31:29], _RANDOM[6'h21][4:0]};
        dataBuffer_uop_robIdx_flag = _RANDOM[6'h21][17];
        dataBuffer_uop_robIdx_value = _RANDOM[6'h21][25:18];
        dataBuffer_uop_storeSetHit = _RANDOM[6'h34][11];
        dataBuffer_uop_waitForRobIdx_flag = _RANDOM[6'h34][12];
        dataBuffer_uop_waitForRobIdx_value = _RANDOM[6'h34][20:13];
        dataBuffer_uop_loadWaitBit = _RANDOM[6'h34][21];
        dataBuffer_uop_loadWaitStrict = _RANDOM[6'h34][22];
        dataBuffer_uop_lqIdx_flag = _RANDOM[6'h34][28];
        dataBuffer_uop_lqIdx_value = {_RANDOM[6'h34][31:29], _RANDOM[6'h35][3:0]};
        dataBuffer_uop_sqIdx_flag = _RANDOM[6'h35][4];
        dataBuffer_uop_sqIdx_value = _RANDOM[6'h35][10:5];
        dataBuffer_preIsSplit = _RANDOM[6'h39][22];
        dataBuffer_mBIndex = _RANDOM[6'h39][26:23];
        dataBuffer_alignedType = _RANDOM[6'h39][29:27];
        dataBuffer_indexVlMaxInVd = {_RANDOM[6'h39][31:30], _RANDOM[6'h3A][5:0]};
        dataBuffer_usLowBitsAddr = _RANDOM[6'h3A][9:6];
        dataBuffer_usAligned128 = _RANDOM[6'h3A][10];
        dataBuffer_usMask = {_RANDOM[6'h3A][31:11], _RANDOM[6'h3B][10:0]};
      `endif // RANDOMIZE_REG_INIT
      if (reset)
        state = 1'h0;
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_in_ready = ~state;
  assign io_out_valid = io_in_valid | state;
  assign io_out_bits_flowMask = state ? dataBuffer_flowMask : io_in_bits_flowMask;
  assign io_out_bits_data = state ? dataBuffer_data : io_in_bits_data;
  assign io_out_bits_baseAddr = state ? dataBuffer_baseAddr : io_in_bits_baseAddr;
  assign io_out_bits_uopAddr = state ? dataBuffer_uopAddr : io_in_bits_uopAddr;
  assign io_out_bits_stride = state ? dataBuffer_stride : io_in_bits_stride;
  assign io_out_bits_flowNum = state ? dataBuffer_flowNum : io_in_bits_flowNum;
  assign io_out_bits_eew = state ? dataBuffer_eew : io_in_bits_eew;
  assign io_out_bits_sew = state ? dataBuffer_sew : io_in_bits_sew;
  assign io_out_bits_emul = state ? dataBuffer_emul : io_in_bits_emul;
  assign io_out_bits_lmul = state ? dataBuffer_lmul : io_in_bits_lmul;
  assign io_out_bits_instType = state ? dataBuffer_instType : io_in_bits_instType;
  assign io_out_bits_indexedSplitOffset =
    state ? dataBuffer_indexedSplitOffset : io_in_bits_indexedSplitOffset;
  assign io_out_bits_uop_preDecodeInfo_isRVC = state & dataBuffer_uop_preDecodeInfo_isRVC;
  assign io_out_bits_uop_ftqPtr_flag =
    state ? dataBuffer_uop_ftqPtr_flag : io_in_bits_uop_ftqPtr_flag;
  assign io_out_bits_uop_ftqPtr_value =
    state ? dataBuffer_uop_ftqPtr_value : io_in_bits_uop_ftqPtr_value;
  assign io_out_bits_uop_ftqOffset =
    state ? dataBuffer_uop_ftqOffset : io_in_bits_uop_ftqOffset;
  assign io_out_bits_uop_fuOpType =
    state ? dataBuffer_uop_fuOpType : io_in_bits_uop_fuOpType;
  assign io_out_bits_uop_rfWen = state & dataBuffer_uop_rfWen;
  assign io_out_bits_uop_fpWen = state & dataBuffer_uop_fpWen;
  assign io_out_bits_uop_vpu_vstart =
    state ? dataBuffer_uop_vpu_vstart : io_in_bits_uop_vpu_vstart;
  assign io_out_bits_uop_vpu_vuopIdx =
    state ? dataBuffer_uop_vpu_vuopIdx : io_in_bits_uop_vpu_vuopIdx;
  assign io_out_bits_uop_vpu_veew =
    state ? dataBuffer_uop_vpu_veew : io_in_bits_uop_vpu_veew;
  assign io_out_bits_uop_uopIdx = state ? dataBuffer_uop_uopIdx : io_in_bits_uop_uopIdx;
  assign io_out_bits_uop_pdest = state ? dataBuffer_uop_pdest : io_in_bits_uop_pdest;
  assign io_out_bits_uop_robIdx_flag =
    state ? dataBuffer_uop_robIdx_flag : io_in_bits_uop_robIdx_flag;
  assign io_out_bits_uop_robIdx_value =
    state ? dataBuffer_uop_robIdx_value : io_in_bits_uop_robIdx_value;
  assign io_out_bits_uop_storeSetHit = state & dataBuffer_uop_storeSetHit;
  assign io_out_bits_uop_waitForRobIdx_flag = state & dataBuffer_uop_waitForRobIdx_flag;
  assign io_out_bits_uop_waitForRobIdx_value =
    state ? dataBuffer_uop_waitForRobIdx_value : 8'h0;
  assign io_out_bits_uop_loadWaitBit = state & dataBuffer_uop_loadWaitBit;
  assign io_out_bits_uop_loadWaitStrict = state & dataBuffer_uop_loadWaitStrict;
  assign io_out_bits_uop_lqIdx_flag =
    state ? dataBuffer_uop_lqIdx_flag : io_in_bits_uop_lqIdx_flag;
  assign io_out_bits_uop_lqIdx_value =
    state ? dataBuffer_uop_lqIdx_value : io_in_bits_uop_lqIdx_value;
  assign io_out_bits_uop_sqIdx_flag =
    state ? dataBuffer_uop_sqIdx_flag : io_in_bits_uop_sqIdx_flag;
  assign io_out_bits_uop_sqIdx_value =
    state ? dataBuffer_uop_sqIdx_value : io_in_bits_uop_sqIdx_value;
  assign io_out_bits_preIsSplit = state ? dataBuffer_preIsSplit : io_in_bits_preIsSplit;
  assign io_out_bits_mBIndex = state ? dataBuffer_mBIndex : io_in_bits_mBIndex;
  assign io_out_bits_alignedType =
    state ? dataBuffer_alignedType : io_in_bits_alignedType;
  assign io_out_bits_indexVlMaxInVd =
    state ? dataBuffer_indexVlMaxInVd : io_in_bits_indexVlMaxInVd;
  assign io_out_bits_usLowBitsAddr =
    state ? dataBuffer_usLowBitsAddr : io_in_bits_usLowBitsAddr;
  assign io_out_bits_usAligned128 =
    state ? dataBuffer_usAligned128 : io_in_bits_usAligned128;
  assign io_out_bits_usMask = state ? dataBuffer_usMask : io_in_bits_usMask;
endmodule

